# Lesson outline
- [L06a: Spring Operating System](https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/L06_Distributed%20Objects%20and%20Middleware.md#l06a-spring-operating-system)
- [L06b: Java RMI](https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/L06_Distributed%20Objects%20and%20Middleware.md#l06b-java-rmi)
- [L06c: Enterprise Java Beans](https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/L06_Distributed%20Objects%20and%20Middleware.md#l06c-enterprise-java-beans)

# L06a: Spring Operating System

<h2>1. Spring Operating System Introduction</h2>

<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/1.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>고급 운영 체제 과정의 다음 모듈에 오신 것을 환영합니다. 이전 모듈의 마지막 부분에서 살펴본 Cornell 실험은 복잡한 소프트웨어 시스템 개발의 문제점을 줄이기 위해 컴포넌트 기반 설계를 주장했습니다. 산업계에서는 운영 체제 및 분산 서비스를 클라이언트-서버 패러다임을 통해 설계하고 상용화하고 있습니다. 또 하나 중요한 문제는 기능성과 성능 측면 모두에서 복잡한 분산 소프트웨어 시스템의 지속적이고 점진적인 진화를 어떻게 설계할 것인가입니다. 이 퍼즐에 대한 짧은 해답은 분산 객체 기술입니다.</li>
  <li>우리는 Tornado 병렬 운영 체제에서 객체 기술이 구조화 도구로 활용되어 병렬 시스템에서 운영 체제 서비스의 확장성을 가능하게 하는 방식을 살펴보았습니다. 이번 고급 운영 체제 과정 모듈에서는 분산 객체 기술이 컴퓨터 산업의 상용 제품에 어떤 영향을 미치고 있는지에 대한 사례를 볼 것입니다.</li>
  <li>이 수업 모듈은 Spring 시스템에 대한 논의로 시작합니다. Spring 시스템은 Sun Micro Systems에서 로컬 영역 네트워크(LAN)에서 사용하기 위한 네트워크 운영 체제로 설계되고 구현되었습니다. 이후 Spring은 Sun의 Solaris 운영 체제로 상용화되었습니다.</li>
  <li>Spring 시스템에 대해 논의하기에 앞서, 약간의 역사와 개인적인 연결이 있습니다. Spring 시스템의 수석 설계자 중 한 명인 Yousef Khalidi는 1989년에 조지아 공대에서 박사 학위를 받았으며, 그 당시 그는 객체 기반 운영 체제인 Clouds 분산 운영 체제를 개발했습니다. 그는 우연히도 제 박사 과정 제자 중 첫 번째였습니다. 놀랍지 않게도 Spring 시스템은 Yousef의 Clouds 관련 작업에 큰 영향을 받았습니다. Spring은 상용 제품으로서 Sun의 Solaris MC로 출시되었습니다. 퀴즈나 잡학에 관심 있는 분들을 위해 덧붙이자면, Yousef는 현재 Microsoft의 Azure 클라우드 컴퓨팅 제품을 총괄하고 있습니다. 참고로, Azure는 그가 대학원생 시절 조지아 공대에서 개발한 Clouds 시스템과는 무관합니다. 이후 우리가 대규모 서비스와 클라우드 컴퓨팅에 대해 논의할 때, Yousef와의 인터뷰를 통해 그가 분산 시스템 서비스의 미래 진화에 대해 가진 생각을 들을 수 있을 것입니다.</li>
</ul>


<h2>2. How to Innovate OS</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/2.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>이제 Sun의 Spring 시스템에 대한 논의로 다시 돌아가겠습니다. 운영 체제에서 어떻게 혁신할 것인가는 언제나 하나의 사각지대(Quadrum)입니다. 학계는 종종 급진적인 아이디어를 추구하는 데 적합하지만, 산업계에서는 항상 "전혀 새로운 운영 체제를 만들어야 할까, 아니면 기존의 잘 알려진 운영 체제를 더 잘 구현해야 할까?"라는 고민을 안고 있습니다. 시장은 일반적으로 자신이 봉사하는 연구 산업을 제약합니다. 특히 1980년부터 2005년까지 Unix 워크스테이션을 만들었던 Sun Microsystems와 같은 기업이라면 더욱 그렇습니다. 이들은 항공사 예약 시스템 등 다양한 응용 프로그램을 위해 24시간 가동되는 복잡한 대형 서버 시스템을 구축하고 있었습니다. 그런 시장 환경에서라면, "완전히 새로운 운영 체제를 만들까, 아니면 기존 운영 체제의 더 나은 구현을 만들까?"라는 질문이 필연적으로 제기됩니다. 시장의 요구는 이렇게 말합니다. "당신의 현재 운영 체제에서 실행되고 있는 레거시 애플리케이션들이 존재합니다. 따라서 산업 환경에서 완전히 새로운 운영 체제를 구축하는 것은 실현 가능성이 떨어질 수 있습니다."</li>

  <li>그래서 Sun Microsystems의 Spring 시스템에서 취한 접근 방식은, 다르게 하되 의미 있는 부분에서 혁신하자는 것이었습니다. 이는 일종의 ‘인텔 인사이드(Intel Inside)’ 전략과도 유사합니다. 프로세서 아키텍처에서 인텔이 지배적이지만, 흥미로운 컴퓨터 아키텍처 연구는 마이크로아키텍처의 내부에서 혁신을 이루는 방식으로 진행됩니다. 외부 인터페이스는 여전히 인텔 프로세서처럼 잘 알려진 형태로 유지되지만, 그 내부에서는 다양한 혁신이 일어나는 것입니다. 이와 마찬가지로, Unix 시스템을 판매하며 고객 기반을 유지하려는 Sun Microsystems와 같은 회사라면 외부 인터페이스는 계속해서 UNIX로 유지하되 내부에서는 의미 있는 혁신을 시도하는 것이 타당합니다. 특히, 운영 체제에서 새로운 API를 제공함으로써 서드파티 벤더들이 그에 맞춰 소프트웨어를 개발하고 이를 운영 체제에 통합할 수 있도록 해야 합니다. 동시에 이러한 통합이 기존의 어떤 것도 망가뜨리지 않도록 보장해야 합니다. 다시 말하면, 표준 운영 체제에서 좋은 부분은 유지하면서도 혁신을 통해 확장성과 유연성을 확보해야 한다는 것입니다.</li>

  <li>Spring 시스템이 바로 이런 접근을 취한 사례이며, 방금 언급한 모든 이유로 인해 객체 지향 방식을 사용하는 것은 내부에서 혁신을 하면서 외부 인터페이스는 동일하게 유지할 수 있는 훌륭한 선택이었습니다.</li>
</ul>


<h2>3. Object based vs Procedural Design</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/3.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>이제 절차적 설계와 객체 기반 설계에 대한 논의로 넘어가겠습니다.</li>

  <li>여러분은 절차적 설계에 익숙할 것입니다. 절차적 설계에서는 코드를 하나의 거대한 단일 구조로 작성하며, 전역 변수와 같은 공유 상태가 존재하고, 호출자와 피호출자 내부에 있는 개인 상태도 있을 수 있습니다. 이처럼 상태는 시스템 전반에 흩어져 있게 됩니다. 기본적으로 호출자와 피호출자 간의 인터페이스는 일반적인 프로시저 호출 메커니즘을 통해 이루어지며, 하나의 하위 시스템이 다른 하위 시스템의 프로시저를 호출하는 식입니다. 이 방식이 바로 상태가 시스템 전반에 퍼져 있는 모놀리식 커널(monolithic kernel)이 구성되는 방식입니다. 일부 상태는 공유되고, 일부는 하위 시스템의 개인 상태일 수 있으며, 모놀리식 시스템은 일반적으로 이런 방식으로 구축됩니다.</li>

  <li>이와 대조되는 객체 기반 설계에서는, 객체가 자신만의 상태를 완전히 내부에 보유하며 외부에는 보이지 않습니다. 이 객체 내부에는 해당 상태를 조작하는 메서드들이 존재하며, 외부에서 볼 수 있는 것은 이러한 메서드뿐입니다. 이 메서드 호출은 객체 내부의 로컬 상태에 대해 작동합니다. 따라서 객체 기반 설계를 통해 얻게 되는 것은 강력한 인터페이스와 객체 상태의 완전한 격리입니다. 반면 절차적 설계에서는 상태가 전체 시스템에 흩어져 있으며, 여러 하위 시스템이 그 공유 상태를 변경할 수 있습니다. 그러나 객체 기반 설계에서는 강한 인터페이스를 통해 객체 간 완전한 분리가 이루어지고, 객체에 특화된 상태는 해당 객체 내부에만 존재하며, 객체 구현자가 정의한 명확한 호출 메서드를 통해서만 외부 접근이 허용됩니다.</li>

  <li>운영 체제를 설계하는 입장에서 당연히 제기될 수 있는 질문은, 이러한 강력한 인터페이스가 결국 운영 체제 구조 논의에서 초기에 이야기했던 보호 도메인(protection domain) 간의 경계 횡단과 유사한데, 이것이 성능 비용을 유발하지는 않을까 하는 것입니다. 하지만 이런 경계 횡단이 성능을 고려하여 설계되도록 하는 우회 방법들이 존재합니다.</li>

  <li>그렇다면 객체 지향 설계를 어디에 적용해야 할까요? 예를 들어, Spring 시스템에서는 객체 지향 설계를 운영 체제 커널을 구축하는 데 적용했습니다. 핵심적으로 기억해야 할 점은, 객체 지향 설계가 고성능 운영 체제 커널을 구현하는 수준에서도 유효하다면, 소프트웨어의 더 높은 수준에서도 당연히 유용하다는 것입니다. 그리고 지금 제가 객체 기반 설계의 장점을 설명하고 있지만, 우리는 이미 Tornado 시스템을 다룰 때 이 방식을 본 적이 있습니다. Tornado 역시 운영 체제 커널을 객체 기반 접근 방식으로 구축했던 예시였습니다.</li>
</ul>


<h2>4. Spring Approach</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/4.JPG?raw=true" alt="drawing" width="700"/>
</p>

<ul> <li>Spring 운영 체제를 구축하는 접근 방식은 각 하위 시스템에 대해 강력한 인터페이스(strong interface)를 구축하는 것입니다. 이것이 의미하는 바는, 외부에 노출되는 것은 해당 하위 시스템이 제공하는 서비스가 무엇인지에 관한 정보일 뿐, 그 서비스가 *어떻게* 구현되는지는 노출되지 않는다는 것입니다. 다시 말해, 내부 구현 방식은 언제든지 변경 가능하며, 단 외부 인터페이스만 유지된다면 문제되지 않습니다. 이것이 강력한 인터페이스의 의미이며, 이는 자연스럽게 객체 지향 설계로 이어집니다.</li> <li>그들은 시스템이 개방적이고 유연하다는 점도 매우 중요하게 생각했습니다. 운영 체제 공급업체라면, 타사의 소프트웨어를 운영 체제에 통합할 수 있어야 하기 때문입니다. 이를 위해 인터페이스는 개방적이고 유연해야 하며, 동시에 하위 시스템의 무결성을 유지할 수 있어야 합니다. 바로 이런 이유 때문에 강력한 인터페이스가 매우 중요한 것입니다.</li> <li>개방성과 유연성은 또한 모든 것을 단일 언어로 작성하지 않아야 한다는 점을 시사합니다. 시스템 구성 요소를 구현하는 데 특정 언어에 종속되어서는 안 되며, 이러한 이유로 Spring에서는 OMG 그룹에서 정의한 IDL(인터페이스 정의 언어)을 사용하기로 했습니다. IDL 컴파일러는 다양한 서드파티 소프트웨어 벤더로부터 제공되며, 이를 통해 개발자는 IDL로 인터페이스를 정의할 수 있습니다. 서드파티 벤더는 이 IDL 정의를 사용하여 자신들의 하위 시스템을 구축하고 Spring 시스템과 통합할 수 있습니다. Spring 접근 방식의 또 다른 핵심은 확장성(extensibility)이며, 이 확장성은 자연스럽게 마이크로커널 기반 접근 방식으로 이어지며, 이는 이 구조에서 확인할 수 있습니다.</li> <li>여기 보이는 Spring 시스템의 구조에서, 붉은 선 아래에 위치한 것이 Spring의 마이크로커널 개념입니다. 사실 이 마이크로커널은 두 부분으로 구성되어 있습니다. 하나는 ‘누클리어스(nucleus)’로, 이는 스레드와 스레드 간의 프로세스 간 통신(IPC)의 추상화를 제공합니다. 그리고 커널 자체는 누클리어스와 가상 메모리 관리자(VM manager)로 구성됩니다. 즉, 누클리어스는 스레드와 IPC를, VM 관리자는 메모리 관리를 제공합니다. 예전에 언급했던 Liedtke의 마이크로커널 원칙을 기억한다면, 이 붉은 선 아래에 있는 구조는 바로 그 원칙에 부합합니다. 마이크로커널이 제공해야 할 것은 스레드와 IPC의 추상화, 그리고 메모리의 추상화이며, 그 외의 모든 요소는 커널 외부에 존재해야 한다는 것입니다.</li> <li>붉은 선 위에 있는 모든 요소는 커널 외부에 있는 구성 요소들이며, 특히 Spring은 Sun Microsystems가 네트워크 운영 체제를 구축하기 위해 제안한 해답입니다. 이는 단일 노드에서 실행되는 운영 체제에서 네트워크 상에서 서비스를 제공하는 체제로의 전환 시기에 해당하는 작업이었습니다. 동일한 인터페이스, 즉 UNIX 인터페이스를 유지하면서 네트워크 운영 체제로 전환하고자 했습니다. 구조도에서 볼 수 있는 ‘네트워크 프록시’는 이러한 연결을 가능하게 해주는 구성 요소이며, 이 프록시에 대해서는 이후 수업에서 더 자세히 다룰 예정입니다. 이 커널 외부의 타원형 구성 요소들은 데스크톱 환경에서 필요한 다양한 서비스를 제공합니다. 예를 들어, X11 서버는 디스플레이 관리자를 의미하며, 셸 수준 프로그래밍, 파일 시스템, 그리고 네트워크 통신(프로토콜 스택 등)을 위한 기능이 포함됩니다.</li> </ul>

<h2>5. Nucleus Microkernel of Spring</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/5.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
<li>Nucleus는 Spring의 마이크로커널이며, 앞서 언급했듯이 Liedtke의 마이크로커널 원칙의 하위 집합에 해당합니다. 구체적으로, Nucleus는 오직 스레드와 프로세스 간 통신(IPC)만을 관리합니다. Nucleus에서 제공하는 추상화는 다음과 같습니다. 먼저 '도메인(domain)'이라는 개념이 있는데, 이는 UNIX 프로세스와 유사하며, 하나의 주소 공간 또는 컨테이너 역할을 합니다. 스레드는 특정 도메인 내에서 실행될 수 있으며, 이 스레드는 우리가 이전에 봤던 Pthread와 의미상 유사합니다. 그리고 "Door(도어)"라는 추상화는 도메인에 대한 소프트웨어 능력(capability)을 의미합니다. 이것은 마치 방에 들어가기 위해 문을 여는 것과 같은 개념입니다. 도어 핸들을 가지고 있다면 해당 도메인의 문을 열고 들어갈 수 있습니다. 이 개념이 바로 도어의 핵심입니다. 따라서 어떤 도메인이든 도어라고 불리는 Nucleus 엔터티를 생성할 수 있으며, 이는 대상 도메인에 들어가기 위한 진입 지점(entry point) 역할을 합니다. 객체 지향 관점에서는 객체에 대해 호출(invocation)을 수행할 수 있어야 하며, 도메인 내에 포함된 객체들과 해당 진입 지점들은 Nucleus가 제공하는 도어라는 추상화로 표현됩니다.</li>

  <li>예를 들어 내가 파일 서버라고 가정해봅시다. 내가 해야 할 일은 무엇일까요? 파일을 열거나, 읽거나, 쓰는 등의 기능을 위한 진입 지점(entry point)을 제공해야 합니다. 이러한 진입 지점들은 내 도메인에 대한 도어(door)로 생성됩니다. 그렇다면 클라이언트는 어떻게 대상 도메인에 존재하는 이러한 진입 지점에 접근할 수 있을까요? 이는 UNIX 파일 시스템에서 `fopen`을 통해 파일 디스크립터를 얻는 방식과 매우 유사합니다. 사용자가 `fopen`을 호출하면, 파일에 접근할 수 있는 핸들로서 작은 정수 값의 파일 디스크립터를 받게 됩니다. 마찬가지로, 클라이언트가 대상 도메인의 특정 진입 지점에 접근하고 싶다면, 도어 핸들(door handle)을 받아야 합니다. 이 도어 핸들은 해당 진입 지점에 접근할 수 있는 권한을 의미합니다.</li> <li>모든 도메인은 자신만의 도어 테이블(door table)을 가지며, 이는 UNIX 프로세스의 파일 디스크립터 테이블과 유사합니다. 도어 테이블 내의 각 도어 ID는 특정 도어를 가리킵니다. 내가 특정 도어에 대한 도어 핸들을 도어 테이블에 가지고 있다면, 이는 곧 해당 도어가 연결된 대상 도메인에서 객체 호출을 수행할 수 있는 권한이 있다는 의미입니다. 도어 핸들을 가진 클라이언트는 해당 도어를 통해 대상 도메인에 객체 호출을 할 수 있습니다. 하나의 클라이언트 도메인은 여러 대상 도메인에 대한 도어 핸들을 도어 테이블에 가질 수 있으며, 예를 들어 두 개의 도어 테이블 항목이 동일한 도어를 가리킬 수도 있고, 서로 다른 도어를 가리킬 수도 있습니다. 그리고 여러 클라이언트가 동일한 도어에 접근할 수도 있습니다. 예컨대 파일 시스템이라면 나도, 당신도 같은 파일 시스템에 접근할 수 있습니다. 요약하자면, 도어 테이블은 각 도메인에 고유하며, 해당 도메인이 대상 도메인의 진입 지점에 접근하여 객체 호출을 수행할 수 있도록 해주는 수단입니다.</li> <li>이 도어 개념을 바라보는 가장 좋은 방법은, 도어가 도메인에 대한 소프트웨어 능력(capability)이라는 점입니다. 객체 지향 방식을 사용하고 있기 때문에, 도어는 대상 도메인을 나타내는 C++ 객체에 대한 포인터로 표현됩니다. 그리고 도어는 도메인 간에 전달될 수 있습니다. 소프트웨어 능력이기 때문에 도메인 간 전송이 가능하며, 전달받은 도메인은 해당 도어를 통해 지정된 대상 도메인의 진입 지점에 접근할 수 있는 권한을 갖게 됩니다.</li>
<li>Spring 커널 자체는 Nucleus와 도메인이 주소 공간을 나타낸다는 점에서 자연스럽게 포함되는 메모리 관리 기능으로 구성됩니다. 그렇다면 객체 호출, 즉 클라이언트 도메인에서 대상 도메인으로 보호된 프로시저 호출(protected procedure call)을 어떻게 수행할 수 있을까요? 이 과정에서 Nucleus는 모든 도어 호출에 관여합니다. 도어는 임의로 열리지 않으며, 반드시 Nucleus의 허가가 필요합니다. 호출자는 자신이 가진 작은 기술자(descriptor), 즉 도어 핸들을 사용하여 호출을 시도하고, Nucleus는 이를 확인한 뒤 "이 도메인은 해당 호출을 수행할 권한이 있다"고 판단하면, 대상 도메인에 서버 스레드를 할당하여 해당 도어 핸들에 지정된 호출을 수행합니다. 이는 보호된 프로시저 호출로, 호출 방식은 일반 프로시저 호출과 같기 때문에 클라이언트 스레드는 비활성화되고, 대상 도메인에 할당된 스레드가 활성화되어 해당 메서드를 실행합니다. 호출이 완료되면 대상 도메인의 스레드는 비활성화되고, 클라이언트의 스레드가 다시 활성화되어 이전 작업을 계속 수행하게 됩니다.</li> <li>이러한 메커니즘은 우리가 앞서 논의했던 Lightweight Remote Procedure Call(LRPC) 방식과 매우 유사합니다. 도어 메커니즘을 사용하여 주소 공간을 넘나드는 호출을 매우 빠르게 수행할 수 있기 때문입니다. 이러한 보호된 프로시저 호출은 Nucleus가 객체 기반 설계를 채택하면서도 성능을 유지하는 방식을 잘 보여줍니다. 즉, 객체 지향 구조를 유지하면서도 클라이언트 스레드를 비활성화하고 대상 도메인의 스레드를 빠르게 활성화하여 진입 지점 프로시저를 실행하고, 완료되면 클라이언트 스레드를 재활성화하는 방식으로 주소 공간 간 호출을 신속하게 처리할 수 있습니다. 이처럼 도어 메커니즘을 통해 객체 지향 설계의 이점을 살리면서도 성능을 희생하지 않는 구조를 구현할 수 있습니다.</li>
</ul>

<h2>6. Object Invocation Across the Network</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/6.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
<li>Spring은 네트워크 운영 체제입니다. 지금까지 설명한 내용은 단일 노드 내에서 객체 호출이 어떻게 이루어지는지를 설명한 것입니다. 이때 사용되는 도어(door)는 단일 노드의 Nucleus에 국한되어 있습니다. 하지만 네트워크 운영 체제이므로, 우리는 네트워크를 넘어서 객체 호출을 수행할 수 있어야 합니다. 즉, 클라이언트 도메인이 한 노드에 있고, 서버 도메인이 로컬 영역 네트워크(LAN)의 다른 노드에 있을 수 있습니다. 이러한 네트워크 상의 클라이언트와 서버 간 객체 호출은 ‘네트워크 프록시(network proxy)’를 통해 확장됩니다.</li> <li>예를 들어, 클라이언트 노드에는 Proxy B가 있고, 서버 노드에는 Proxy A가 있을 수 있습니다. 서로 다른 서버에 연결하기 위해서는 서로 다른 프록시가 사용될 수 있으며, 클라이언트는 Proxy B를 사용하여 특정 서버와 통신할 수 있고, 다른 서버와 통신할 때는 Proxy C와 같은 전혀 다른 프록시를 사용할 수도 있습니다. 다시 말해, 프록시는 다양한 프로토콜을 사용할 수 있는 구조로 설계되어 있으며, 이는 클라이언트와 서버 간 통신이 LAN인지 WAN인지에 따라 적절한 프로토콜을 선택할 수 있는 유연성을 제공합니다. 바로 이런 점이 Sun이 Spring 네트워크 운영 체제를 설계할 때 중시한 핵심 속성 중 하나입니다. 단일 노드의 운영 체제 내부에 네트워크 연결 방식이 고정되지 않도록 하고, 각 클라이언트가 접근하는 서버의 위치에 따라 클라이언트와 서버 머신에 있는 프록시 간 통신 방식(프로토콜)을 적절히 선택할 수 있도록 한 것입니다.</li> <li>또한 중요한 점은, 이러한 프록시들은 클라이언트와 서버에게는 ‘투명’하다는 것입니다. 즉, 클라이언트와 서버는 자신들이 같은 머신에 있는지 다른 머신에 있는지조차 알 필요가 없고, 신경 쓸 필요도 없습니다. 이처럼 Spring은 네트워크 분산 환경을 자연스럽게 통합할 수 있도록 설계되어 있으며, 프록시를 통해 위치 독립성과 프로토콜 유연성을 동시에 제공하는 구조를 갖추고 있습니다.</li>
  <li>이제 이러한 프록시를 통해 클라이언트-서버 관계가 어떻게 설정되는지를 살펴보겠습니다. 네트워크를 통해 클라이언트와 서버 간의 연결이 이루어져야 할 때, 가장 먼저 수행되는 작업은 서버 노드에서 프록시 A(Proxy A)를 인스턴스화하고, 서버 도메인과 Proxy A 사이에 통신을 위한 도어(Door X)를 Nucleus를 통해 설정하는 것입니다. 이후 Proxy A는 이 Door X를 포함한 네트워크 핸들(network handle)을 클라이언트 도메인에 있는 상대 프록시인 Proxy B에 전달하게 됩니다. 이 Proxy A와 Proxy B 간의 상호작용은 Nucleus의 관리 범위를 벗어나는 영역입니다. 즉, 이 네트워크 핸들은 Spring 시스템의 Nucleus가 제공하는 기본 프리미티브나 메커니즘과는 무관하게 설정됩니다.</li> <li>Proxy A는 Door X를 내포하는 네트워크 핸들을 생성하고 이를 Proxy B에 내보냅니다(export). Proxy B는 자신이 위치한 클라이언트 노드의 Nucleus B 상에서 클라이언트 도메인과 통신하기 위한 자체적인 도어(Door Y)를 이미 설정해 두고 있으며, 이 도어를 통해 클라이언트 도메인과 연결됩니다. 그리고 Proxy B는 Proxy A로부터 받은 네트워크 핸들을 사용하여 두 Nucleus 간의 연결을 설정합니다. 이 때 이루어지는 네트워크 핸들 기반의 통신은 모두 Nucleus 바깥에서 이루어지며, 이는 매우 중요한 설계 특징입니다.</li> <li>이제 클라이언트가 실제로 서버 도메인에 호출을 수행하려고 할 때 어떤 일이 벌어질까요? 클라이언트는 자신이 Door Y를 통해 호출하고 있다고 생각하지만, 실제로는 Door Y는 Proxy B에 존재하며, 이 호출은 Proxy B로 전달됩니다. 이 도어에 대한 접근은 Nucleus B에 의해 허가된 것입니다. 이후 Proxy B는 Proxy A와 공유하고 있는 네트워크 핸들을 사용하여 해당 호출을 Proxy A에 전달합니다. Proxy A는 이 호출이 클라이언트로부터 온 것임을 인식하고, 자신이 보유한 Door X를 통해 서버 도메인에 접근하여 실제 호출을 수행합니다.</li> <li>요약하자면, 클라이언트는 Door X를 열고자 하지만, 서버 도메인이 네트워크 상의 다른 노드에 있기 때문에 Door X에 직접 접근할 수 없습니다. 이를 해결하기 위해 서버 도메인의 진입 지점인 Door X는 프록시 A에 의해 네트워크 핸들로 변환되어 클라이언트 노드의 프록시 B로 전달됩니다. Proxy B는 이 핸들을 통해 두 노드의 Nucleus 간 연결을 설정하고, 클라이언트는 Door Y를 호출함으로써 마치 Door X를 직접 호출하는 것처럼 행동하게 됩니다. Proxy B는 이 호출을 Proxy A로 전달하고, Proxy A는 실제 Door X를 사용하여 서버 도메인 내에서 해당 호출을 수행합니다.</li>
</ul>

<h2>7. Secure Object Invocation</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/7.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>서버 객체가 서로 다른 클라이언트에게 서로 다른 권한 수준을 제공해야 하는 경우가 자주 발생할 수 있습니다. 예를 들어 파일 서버가 있다면, 사용자 계층에 따라 파일에 대한 접근 권한이 다르게 설정되어야 할 수 있습니다. 이러한 객체에 대한 차등 호출(differential invocation)을 가능하게 하기 위해, Spring이 제공하는 보안 모델은 **프론트 객체(front object)**라는 개념을 기반으로 합니다. 여기서 말하는 ‘기저 객체(underlying object)’는 실제 서비스를 수행하는 객체이고, 이 객체 앞에 위치한 프론트 객체는 Spring의 표준 객체 호출 의미 체계와는 무관하게 작동합니다. 즉, 프론트 객체와 기저 객체 사이의 연결은 오직 서비스 구현자의 책임이며, Spring 시스템이 제공하는 도어 메커니즘을 통해 이루어지는 것이 아닙니다.</li> <li>클라이언트 도메인이 접근할 수 있는 것은 오직 이 프론트 객체입니다. 프론트 객체는 자신에 대한 도어를 Nucleus에 등록하여, 클라이언트가 해당 도어를 통해 자신에게 접근할 수 있도록 합니다. 그런 다음 프론트 객체는 **접근 제어 목록(ACL)**을 확인하여, 클라이언트 도메인이 기저 객체에 대해 어떤 권한을 가지고 있는지를 판단합니다. 그리고 필요에 따라 하나의 기저 객체에 대해 여러 개의 프론트 객체를 만들고, 서로 다른 도어를 Nucleus에 등록하여 서로 다른 제어 정책을 구현할 수 있습니다. 즉, 기저 객체의 서비스 접근 정책은 이 프론트 객체(또는 그 다양한 인스턴스) 안에 구현되며, 이로 인해 다양한 보안 정책과 권한 구분이 가능해집니다. 클라이언트의 호출이 프론트 객체를 통해 들어오면, ACL이 먼저 확인되고, 그 결과에 따라 호출이 기저 객체로 전달될지 여부가 결정됩니다.</li> <li>앞서 언급했듯이, 클라이언트 도메인이 서버의 호출 진입 지점(entry point), 즉 도어에 접근할 수 있다면, 이는 소프트웨어 능력(capability)이므로 다른 도메인에 이를 전달할 수 있습니다. 이 도어 핸들은 다른 클라이언트 도메인에게 공유될 수 있으며, 동일한 객체에 접근하는 수단으로 활용됩니다. 이 과정에서 원래의 클라이언트 도메인은, 객체 접근 권한을 동일하게 줄 것인지, 아니면 더 낮은 수준의 권한만 줄 것인지 선택할 수 있습니다. 이러한 정책 역시 프론트 객체를 통해 구현될 수 있습니다.</li>
 <li>예를 들어 사용자가 `foo`라는 파일을 인쇄하고 싶다고 가정해봅시다. 이 사용자는 자신이 생성한 객체인 파일 시스템 내의 이 파일에 대해 완전한 접근 권한을 가지고 있습니다. 즉, `foo` 객체에 대한 참조(reference)를 가지고 있고, 이에 대한 모든 권한을 갖고 있습니다. 하지만 이 파일을 인쇄할 때, 프린터 객체에게는 이 작업에 필요한 최소한의 권한만 부여하고 싶습니다. 특히, 인쇄라는 작업을 수행하기 위해 필요한 것은 일회성(one-time) 접근 권한에 불과합니다.</li>

<li>따라서 사용자는 자신이 가진 `foo` 파일에 대한 소프트웨어 능력(capability)을 줄여서, 동일한 객체에 대한 참조는 유지하되, 이를 **일회성 참조**로 변환합니다. 이제 프린터 객체는 이 일회성 권한을 가지고 파일 시스템에 접근하게 됩니다. 파일 시스템과 연결된 프론트 객체는 이 프린터 객체가 제시한 권한을 확인하고, “이 일회성 티켓은 아직 사용되지 않았다”고 판단되면 접근을 허용하여 파일 인쇄 작업을 수행하게 합니다. 하지만 동일한 핸들을 다시 제시한다면, 프론트 객체는 이미 사용된 권한으로 판단하고 접근을 거부합니다. 이처럼 사용자로부터 프린터 객체로 제공된 권한은 **일회성 능력(one-time capability)**이며, 보안 정책은 프론트 객체를 통해 엄격히 관리됩니다.</li>

<li>정리하자면, 우리는 객체 호출이 **도어 메커니즘과 스레드 핸드오프(thread hand-off)**를 통해 단일 노드 내에서 어떻게 효율적으로 수행되는지, **프록시를 통해 네트워크를 넘어** 어떻게 확장되는지, 그리고 **프론트 객체를 통한 접근 정책 설정**으로 어떻게 보안이 보장되는지를 살펴보았습니다. 이러한 메커니즘들은 모두 Spring 커널이 제공하는 기능이며, 바로 이 부분이 Spring 시스템의 혁신이 구현되는 핵심입니다. 외부적으로는 UNIX 운영 체제처럼 보이지만, 내부적으로는 객체 지향 기술을 활용하여 운영 체제를 구조화하는 다양한 혁신이 적용되어 있는 것입니다.</li>

</ul>

<h2>8. Abstractions</h2>

<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/8.JPG?raw=true" alt="drawing" width="500"/>
</p>

<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/9.JPG?raw=true" alt="drawing" width="500"/>
</p>


<h2>9. Virtual Memory Management in Spring</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/10.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
<li>가상 메모리 관리는 Spring 커널의 구성 요소 중 하나이며, 이제 Spring 운영 체제에서 가상 메모리 관리가 어떻게 이루어지는지에 대해 설명하겠습니다. Spring에서는 **각 머신마다 독립적인 가상 메모리 관리자(Virtual Memory Manager, VMM)**가 존재하며, 이 관리자는 각 프로세스의 선형 주소 공간(linear address space)을 관리하는 책임을 집니다. 우리가 알고 있듯이, 선형 주소 공간은 하드웨어 아키텍처가 프로세스에게 제공하는 연속된 가상의 주소 공간입니다. VMM은 이 선형 주소 공간을 여러 개의 **영역(region)**으로 분할합니다. 각 영역은 여러 페이지(page)들로 구성되며, 영역마다 크기가 다를 수 있습니다.</li> <li>가상 메모리 시스템에서 두 번째 핵심 추상화는 **메모리 객체(memory object)**입니다. 선형 주소 공간을 영역 단위로 분할하는 목적은, 각 영역을 서로 다른 메모리 객체에 매핑할 수 있게 하기 위함입니다. 예를 들어, 하나의 영역은 하나의 메모리 객체 전체에 매핑될 수 있고, 다른 영역은 동일한 메모리 객체의 일부분에 매핑될 수 있으며, 동일한 프로세스의 서로 다른 두 영역이 같은 메모리 객체에 매핑되는 것도 가능합니다. 이런 방식으로 VMM은 프로세스의 선형 주소 공간을 메모리 객체에 연결합니다.</li> <li>그렇다면 **메모리 객체란 무엇인가요?** 메모리 객체는 **가상 메모리의 특정 영역을 백업 저장소(backing store)**와 연결할 수 있도록 해주는 추상화입니다. 이 백업 저장소는 디스크 상의 스왑 공간(swap space)일 수도 있고, 파일 시스템의 특정 파일일 수도 있습니다. 따라서 메모리 객체를 통해 주소 공간의 일부를 디스크 상의 다양한 엔티티에 매핑할 수 있게 됩니다. 또한, 여러 메모리 객체가 동일한 백업 파일을 참조하는 것도 가능합니다.</li> <li>요약하자면, Spring의 가상 메모리 관리에서 사용되는 추상화 구조는 다음과 같습니다: 1) **선형 주소 공간** → 2) **여러 개의 영역(region)으로 분할** → 3) **각 영역은 메모리 객체에 매핑됨** → 4) **메모리 객체는 디스크 상의 백업 저장소를 추상화함** (예: 스왑 공간, 파일 시스템의 파일 등) 이제 다음으로, 이러한 메모리 객체들이 실제로 어떻게 물리 메모리로 페이징(paging)되어 들어오는지를 살펴볼 것입니다.</li>
</ul>

<h2>10. Memory Object Specific Paging</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/11.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
<li>이제 가상 메모리 관리자(Virtual Memory Manager, VMM)의 역할에 대해 더 자세히 살펴보겠습니다. 가상 메모리 관리자는 자신이 관장하는 주소 공간에 대해 책임을 집니다. 이 관리자는 선형 주소 공간을 여러 **영역(region)**으로 분할하고, 각각의 영역을 특정 **메모리 객체(memory object)**에 매핑합니다. 하지만 한 프로세스가 이러한 메모리 객체에 실제로 접근하려면, 해당 객체의 데이터가 **물리 메모리(DRAM)**에 존재해야 하며, 이를 담당하는 것이 바로 **페이저 객체(pager object)**입니다. 이 개념은 Mach 시스템에서 말하는 **external pager**와 유사합니다.</li> <li>**페이저 객체**는 가상 메모리와 물리 메모리 사이의 연결을 설정하는 책임을 지닙니다. 특정 선형 주소 공간의 일부, 즉 특정 영역이 어떤 메모리 객체에 매핑되어 있을 때, 프로세스가 해당 영역에 접근하려 하면 페이저 객체가 나서서 해당 메모리 객체가 DRAM에 존재하도록 만듭니다. 이를 통해 접근 요청이 있을 때 해당 메모리 객체가 실제 물리 메모리에 존재하게 됩니다.</li> <li>이 페이저 객체는 DRAM 상에 **캐시된 객체 표현(cached object representation)**을 생성하여 메모리 객체를 물리 메모리에 로드합니다. 결과적으로, VMM이 특정 메모리 객체에 매핑해 둔 주소 공간의 영역은, 페이저 객체의 작업 덕분에 프로세스가 DRAM 상에서 접근할 수 있게 됩니다.</li> <li>비슷하게, 또 다른 가상 메모리 관리자가 다른 주소 공간을 관리하고 있을 때, 그 역시 다른 메모리 객체를 매핑하고, 해당 객체에 대해 또 다른 페이저 객체를 통해 캐시 표현을 생성할 수 있습니다. 즉, 여러 VMM들이 서로 다른 프로세스에 대해 동일하거나 서로 다른 메모리 객체를 매핑하고 관리할 수 있는 구조입니다.</li> <li>가상 메모리 관리자는 선형 주소 공간의 다양한 영역을 여러 메모리 객체에 자유롭게 매핑할 수 있으며, 각 메모리 객체는 해당 객체의 물리적 표현을 담당하는 페이저 객체에 의해 관리됩니다. 예를 들어, 하나의 선형 주소 공간 내 또 다른 영역이 동일한 메모리 객체에 매핑될 수도 있습니다. 이 경우 해당 메모리 객체는 DRAM에 하나의 캐시 표현을 가지며, 이는 해당 VMM이 관리하는 프로세스의 주소 공간의 일부로 사용됩니다. 예시에서, **Pager 1**은 두 개의 서로 다른 메모리 객체(Memory Object 1과 Memory Object 2)를 관리하고 있으며, 이는 VMM1이 관리하는 프로세스의 주소 공간 내에서 사용되고 있습니다. 즉, 각각의 메모리 객체에 대해 페이저 객체가 존재하며, 이들은 객체의 페이징을 책임집니다.</li>
<li>여기서 강조하고 싶은 중요한 점은, **모든 메모리 객체에 대해 동일한 페이징 메커니즘을 사용할 필요가 없다는 것**입니다. 즉, 하나의 프로세스 내 선형 주소 공간의 서로 다른 영역(region)들이 **각기 다른 메모리 객체에 연결**되고, 각 메모리 객체는 **다른 페이저 객체(pager object)**를 통해 관리될 수 있다는 것입니다. 이러한 영역과 메모리 객체 간의 연결은 **동적으로 생성**될 수 있습니다.</li> <li>예를 들어, 주소 공간 관리자(VMM1)가 선형 주소 공간의 특정 영역을 새로운 메모리 객체(obj3)에 연결하기로 결정했다고 합시다. 이 경우, 이 연결을 관리하는 **새로운 페이저 객체**가 생성되며, 이 객체는 해당 영역과 obj3 간의 매핑을 관리하고, obj3의 DRAM 상의 **캐시 표현(cached object representation)**을 생성합니다. 이때 특이한 상황이 발생하는데, obj3는 두 개의 서로 다른 주소 공간(VMM1과 VMM2)에 공유되고 있습니다. 즉, 동일한 메모리 객체를 서로 다른 주소 공간에서 사용하고 있으며, 각각의 주소 공간은 자신만의 **고유한 페이저 객체**를 통해 obj3와의 연결을 관리합니다.</li> <li>그렇다면 여기서 문제는 **캐시 일관성(cache coherence)**입니다. DRAM 상에 존재하는 두 개의 obj3 캐시 표현이 일치해야 할 경우, 누가 그 일관성을 보장할까요? 그 책임은 Spring 시스템이 아닌, 각각의 **페이저 객체에 위임**됩니다. 즉, 해당 메모리 객체와 물리 메모리 간의 매핑을 관리하는 페이저 객체들끼리 협력하여 일관성을 유지해야 하며, 이는 설계자의 판단과 구현에 맡겨져 있습니다.</li> <li>요약하자면, Spring 시스템의 메모리 관리 방식은 다음과 같은 구조를 따릅니다: 1) **주소 공간 관리자(VMM)**는 프로세스의 선형 주소 공간을 관리하며, 이를 **영역(region)** 단위로 분할하고, 2) 각 영역을 **메모리 객체(memory object)**에 연결합니다. 3) 메모리 객체는 스왑 공간이나 메모리 맵핑된 파일 등으로, 사용자 목적에 따라 다양하게 활용될 수 있습니다. 4) 이러한 메모리 객체를 DRAM에 **캐시 형태로 매핑**하는 작업은 **페이저 객체(pager object)**의 책임이며, 5) 하나의 주소 공간에 대해 **여러 개의 페이저 객체**가 존재하여, 서로 다른 영역을 각기 독립적으로 관리할 수 있습니다.
이처럼 Spring 시스템은 객체 기술(object technology)을 기반으로, 유연하고 확장 가능한 메모리 관리 구조를 제공합니다. 이는 사용자 요구에 맞춘 다양한 메모리 접근 방식과 캐시 정책을 구현할 수 있는 강력한 기반이 됩니다.</li>
</ul>

<h2>11. Spring System Summary</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/12.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
 <li>Spring 시스템에서 제공되는 주요 메커니즘들을 요약하자면 다음과 같습니다. **객체 지향(object orientation)** 및 **객체 기술(object technology)**은 운영 체제 설계 전반에 걸쳐 깊이 스며들어 있으며, 이는 네트워크 운영 체제를 구조화(structuring)하는 핵심 수단으로 사용됩니다. 구체적으로 살펴보면, Spring 시스템은 **Nucleus**를 중심으로 구성되며, 이는 **스레드와 스레드 간 IPC(inter-process communication)**를 제공합니다.</li>

<li>**Liedtke의 마이크로커널 원칙**은 Nucleus와 주소 공간 관리(address space management)의 조합을 통해 구현됩니다. 이들은 Spring 커널 경계 내에 존재하는 구성 요소이며, 파일 시스템, 네트워크 통신 등 운영 체제의 전통적인 서비스들은 모두 커널 외부에 위치한 **객체(object)**로 제공됩니다.</li>

<li>이러한 객체에 접근하기 위한 메커니즘이 바로 **도어(door)**입니다. 각 도메인에는 자신이 접근할 수 있는 도어에 대한 권한(capability)을 담고 있는 **도어 테이블(door table)**이 존재하며, 이 구조는 **도메인 간 호출(cross-domain calls)**의 기초가 됩니다.</li>

<li>Spring은 객체 지향 설계와 **네트워크 프록시(proxy)**를 결합하여, **동일 노드 내에서는 보호된 프로시저 호출(protected procedure calls)**로, 그리고 네트워크를 넘어서도 투명하게 **객체 호출(object invocation)**을 수행할 수 있게 합니다.</li>

<li>또한, Spring은 가상 메모리 관리를 위해 다음과 같은 기본 추상화를 제공합니다:  
– **선형 주소 공간(linear address space)**  
– **메모리 객체(memory object)**  
– **외부 페이저(external pager)**  
– **캐시 표현(cached object representation)**  
이러한 구조를 통해 유연하고 확장 가능한 메모리 관리를 실현합니다.</li>

<li>마지막으로, Spring과 Tornado 시스템 간의 비교를 해보면, 두 시스템 모두 객체 기술을 사용하지만 그 **목적과 적용 범위**는 분명히 다릅니다. **Tornado**에서는 객체 기술이 **커널 서비스 최적화**를 위한 수단으로 사용됩니다. 예를 들어, 특정 객체가 **단일 인스턴스(singleton)**인지, 아니면 각 프로세서마다 **분산 인스턴스(clustered objects)**를 가지는지와 같은 구조적 최적화가 주요 활용 방식입니다. 반면, **Spring 시스템에서는 객체 기술이 운영 체제를 구성하는 전체적인 구조적 틀**로 사용되며, 단순한 최적화 기법이 아닌, **운영 체제 전체 설계 철학의 핵심 요소**로 자리 잡고 있습니다.</li>

</ul>

<h2>12. Dynamic Client Server Relationship</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/13.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>Spring은 **네트워크 운영 체제**입니다. 클라이언트와 서버는 동일한 머신에 있을 수도 있고, 로컬 영역 네트워크(LAN)의 서로 다른 노드에 위치할 수도 있습니다. Spring 시스템이 추구한 핵심 개념 중 하나는 **확장성(extensibility)**이며, 이를 네트워크 전반으로 확장시켜 **클라이언트와 서버가 물리적으로 어디에 있든지 상호작용이 영향을 받지 않아야 한다**는 목표를 세웠습니다. 다시 말해, 클라이언트-서버 간 상호작용이 **위치로부터 독립적**이어야 한다는 것입니다.</li>

  <li>예를 들어, 그림에서처럼 클라이언트와 서버가 같은 머신에 있을 수도 있지만, **서버를 복제(replication)**하여 가용성을 높이려는 결정을 내릴 수도 있습니다. 이 경우 여러 서버 복제본이 존재하게 되고, **클라이언트 요청은 동적으로 서로 다른 서버로 분산(load distribution)**됩니다. 오늘날 Google과 같은 서비스가 동작하는 방식과 매우 유사한 구조로, 사용자 요청은 여러 서버 중 하나로 라우팅되며, 이는 **클라이언트의 물리적 위치**나 **서버의 현재 부하 상태** 등에 따라 결정됩니다. Spring 시스템에서도 마찬가지로, 서버가 복제되면 클라이언트 요청은 동적으로 적절한 서버로 라우팅됩니다.</li>

  <li>이와 유사한 또 다른 패턴은 서버가 복제되는 것이 아니라 **캐싱(caching)**되는 경우입니다. 예를 들어 웹 서버의 경우, 원래의 웹 서버가 아닌 **프록시 형태의 캐시된 복사본**에 클라이언트 요청을 전달할 수 있습니다. 이때도 클라이언트 요청은 반드시 원본 서버(origin server)로 갈 필요 없이, **캐시된 서버 복사본**으로 라우팅될 수 있으며, 이 라우팅 결정 역시 **동적으로** 이루어집니다.</li>

  <li>이 모든 동작 — 클라이언트와 서버가 같은 머신에 있을 때의 호출, 서버 복제를 통한 분산 요청 처리, 서버 캐싱을 통한 요청 라우팅 — 은 모두 **동적으로 결정되는 일련의 정책**입니다. 이러한 **동적 클라이언트-서버 관계 구성과 요청 라우팅**이 어떻게 가능해지는지에 대한 구체적인 메커니즘은, 이제 다음에서 살펴보게 될 내용입니다.</li>
</ul>


<h2>13. Subcontract</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/14.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>클라이언트와 서버 간의 **동적 관계**를 가능하게 하는 핵심 메커니즘이 바로 **서브컨트랙트(Subcontract)**입니다. 현실 세계에서 어떤 작업을 제3자에게 하청(subcontract) 주듯이, Spring 네트워크 운영 체제에서도 이와 유사한 방식으로 객체 호출을 처리합니다. 앞서 설명했듯이, 클라이언트와 서버 간의 기본적인 계약은 **IDL(Interface Description Language)**을 통해 정의됩니다. 이 IDL은 클라이언트와 서버 간의 호출 규약(인터페이스)을 정의합니다. 그리고 **서브컨트랙트는 이 IDL 계약을 실현하는 구체적인 실행 메커니즘**입니다.</li>

  <li>즉, 클라이언트는 서버의 IDL 인터페이스를 통해 호출을 수행하고, 이 인터페이스의 **구현은 서브컨트랙트를 통해 이루어집니다**. 다시 말해, 서브컨트랙트는 **객체의 런타임 동작을 인터페이스로부터 분리**해주는 메커니즘입니다. 예를 들어, 서버가 단일 인스턴스(singleton)로 존재할 수도 있고, 복제(replication)되어 있을 수도 있지만, **클라이언트는 그 사실을 알 필요도 없고, 알지도 못합니다**. 이러한 세부 구현은 모두 서브컨트랙트 내부에서 처리되므로, **클라이언트 측 스텁(stub) 생성은 매우 단순해집니다**. 서버가 어디에 있는지, 같은 머신에 있는지, 다른 머신에 있는지, 서버가 여러 개 존재하는지, 어떤 서버에 요청을 보내야 하는지 등은 **모두 서브컨트랙트가 처리합니다**.</li>

  <li>서브컨트랙트는 **IDL 인터페이스 아래에서 동작**하며, 언제든지 교체될 수 있습니다. 예를 들어, 어떤 작업을 수행하던 하청업체를 다른 하청업체로 바꾸듯이, 기존 서브컨트랙트를 **런타임 중에 동적으로 교체하거나 새로 설치**할 수 있습니다. 예를 들어, 단일 서버가 복제되었다면, 이 새로운 복제된 서버를 지원하는 **새로운 서브컨트랙트가 동적으로 로드**되어 적용됩니다. 이때 IDL 인터페이스나 클라이언트 스텁 코드는 **일절 변경할 필요가 없습니다**. 모든 변경은 서브컨트랙트 레벨에서 이루어지며, 상위 계층에는 영향을 미치지 않습니다.</li>

  <li>요약하자면, **서브컨트랙트는 객체 호출의 실제 동작 방식(위치, 복제, 접근 방법 등)을 캡슐화**하여, 클라이언트는 단순한 인터페이스만 보고 호출을 할 수 있게 해줍니다. 이로 인해 **동적 확장성, 유연성, 유지보수성**이 매우 뛰어난 구조가 완성되며, Spring 시스템이 **기존 서비스를 변경 없이 확장하거나 기능을 추가**할 수 있게 해주는 강력한 수단이 됩니다.</li>
</ul>

<p><b>요약: IDL과 Subcontract에 대한 설명 (출처: Mitchell et al., "An overview of the Spring system", COMPCON'94)</b></p>

<ul>
  <li><b>IDL (Interface Description Language):</b>  
    Spring 시스템에서 IDL 컴파일러는 다음과 같은 세 가지 소스 코드 조각을 생성합니다:
    <ol>
      <li>IDL 인터페이스의 언어별 표현</li>
      <li><b>클라이언트 측 스텁 코드:</b> 클라이언트 프로그램에 동적으로 링크되어, 다른 주소 공간이나 다른 머신에 있는 객체에 접근할 수 있도록 해줌</li>
      <li><b>서버 측 스텁 코드:</b> 객체 매니저에 링크되어, 원격 객체 호출을 해당 객체 구현의 런타임 환경으로 변환</li>
    </ol>
    IDL은 객체의 연산이 어떻게 구현되는지 또는 호출 요청이 어떻게 전달되는지에 대해서는 아무런 정보도 제공하지 않습니다. 이러한 세부 구현은 객체의 런타임 환경과 실제 객체 구현의 책임입니다.
  </li>

  <li><b>스텁 (Stubs):</b>  
    서버 기반 객체에 대해 스텁은 자동으로 생성되며, 클라이언트 호출 시 전달되는 인자를 서버로 전송하기 위해 **마샬링(marshalling)**하고, 결과를 **언마샬링(unmarshalling)**하여 클라이언트 애플리케이션으로 반환합니다.  
    이 스텁들은 **Spring의 subcontract 메커니즘을 이용해** 원격 서버와 통신합니다.
  </li>

  <li><b>서브컨트랙트 (Subcontract):</b>  
    Spring은 다양한 유형의 객체 런타임 메커니즘을 플러그인할 수 있는 유연한 구조를 제공합니다. 이 구조가 바로 **subcontract**입니다.  
    서브컨트랙트는 다음과 같은 객체 런타임 동작을 제어할 수 있도록 합니다:
    <ul>
      <li>객체 호출이 어떻게 구현되는지</li>
      <li>객체 참조가 주소 공간 사이에서 어떻게 전달되는지</li>
      <li>객체 참조가 어떻게 해제되는지</li>
      <li>그 외 유사한 런타임 작업</li>
    </ul>
    예를 들어, <b>singleton subcontract</b>는 객체 구현이 있는 주소 공간으로 요청을 전달하여 호출을 수행하며,  
    <b>replicated subcontract</b>는 객체를 복제한 여러 서버 중 하나 이상으로 요청을 전달하여 호출을 수행할 수 있습니다.
  </li>
</ul>

<h2>14. Subcontract Interface for Stubs</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/15.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>이제 클라이언트와 서버 측 스텁이 **서브컨트랙트(subcontract) 메커니즘을 통해 사용하는 인터페이스**에 대해 살펴보겠습니다.</li>

  <li>첫 번째 인터페이스는 **마샬링(marshaling) 및 언마샬링(unmarshaling)**을 위한 것입니다. 클라이언트 측 스텁은 호출 시 전달할 인자들을 마샬링해야 합니다. 이를 위해 스텁은 서브컨트랙트에 "이 인자들을 마샬링해줘"라는 식의 호출을 하게 됩니다. 그러면 서브컨트랙트는 그 호출이 네트워크를 통해 서버로 갈 것인지, 같은 머신의 다른 주소 공간으로 갈 것인지, 아니면 동일 머신의 다른 프로세서로 갈 것인지 등을 판단하고, 그에 맞게 적절한 방식으로 마샬링을 수행합니다. 이 모든 세부사항은 **서브컨트랙트 내부에 캡슐화되어** 있기 때문에, 클라이언트 스텁은 **복잡한 로직 없이 간단한 호출만 수행**하면 됩니다. 이 마샬링 로직은 **서버 측에서도 동일하게 동작**합니다.</li>

  <li>마샬링이 완료되면, 클라이언트는 호출(invocation)을 실행합니다. 이때 서브컨트랙트는 "이 호출이 정확히 어디로 가야 하는지"를 알고 있기 때문에, 호출을 적절한 대상에게 전달합니다. 따라서 **호출 전달 메커니즘도 서브컨트랙트가 담당**합니다. 반면, 서버 측의 서브컨트랙트는 다른 종류의 인터페이스를 제공합니다. 예를 들어, 서버가 서브컨트랙트에게 “서비스 준비 완료”를 알리거나, 특정 서비스를 철회(revoke)할 수 있는 기능이 포함됩니다.</li>

  <li>중요한 점은, **클라이언트와 서버의 스텁은 동일 머신에 있든, 다른 노드에 있든, 서버가 복제되어 있든, 캐시된 복사본이든 간에 전혀 다르게 동작할 필요가 없다는 것**입니다. **모든 위치 투명성과 실행 환경의 차이점은 서브컨트랙트가 처리**합니다. 즉, 클라이언트 애플리케이션과 클라이언트 스텁, 그리고 서버와 서버 스텁은 환경이 어떻게 바뀌든 **아무것도 변경할 필요가 없습니다**.</li>

  <li>요약하자면, Spring 시스템의 혁신은 다음과 같습니다:
    <ul>
      <li>**객체 기술(object technology)**을 전체 운영 체제 구조화의 핵심 메커니즘으로 활용</li>
      <li>**강력한 인터페이스**, **개방성**, **유연성**, **확장성**을 갖춘 구조 (모놀리식이 아닌 마이크로커널 기반)</li>
      <li>운영 체제의 모든 서비스는 커널 외부에서 객체 형태로 제공됨</li>
      <li>클라이언트와 서버는 서로 같은 노드에 있는지, 다른 노드에 있는지 알 필요 없음</li>
      <li>**객체 호출은 네트워크 프록시를 통해 투명하게 수행됨**</li>
      <li>**서브컨트랙트 메커니즘**을 통해 클라이언트와 서버 간의 관계를 동적으로 재구성 가능  
        → 새로운 서버 인스턴스를 생성하고, 클라이언트는 코드를 변경하지 않고도 동적으로 새 인스턴스에 바인딩할 수 있음</li>
    </ul>
    이처럼 Spring은 **"외부 인터페이스는 그대로 두고 내부를 혁신적으로 설계하는 것"**을 목표로 하였으며, Sun은 이를 Spring 시스템을 통해 실제로 구현해낸 것입니다.
  </li>
</ul>


<h2>15. Spring Operating System Conclusion</h2>
<ul>
  <li>이번 강의에서 여러분은 **시스템 내부를 혁신하는 방식**, 즉 외부적으로는 기존 UNIX 시스템처럼 보이지만, **내부 구조는 객체 기술을 통해 완전히 재구성된 사례**를 Spring 시스템을 통해 이해했을 것입니다. Sun은 외부적으로 여전히 UNIX 워크스테이션을 판매하고 있었지만, 실제로는 **네트워크 운영 체제의 구조를 객체 기반 기술로 혁신**하고 있었습니다.</li>

  <li>특히, Spring 시스템의 핵심 메커니즘 중 하나인 **서브컨트랙트(subcontract)**는 이후 많은 자바 프로그래머들이 사용하는 기술의 기반이 되었습니다. 바로 **Java RMI(Remote Method Invocation)**입니다. 다음 강의에서는 이 **Java RMI**와 함께 **Enterprise JavaBeans(EJB)**에 대해서도 다룰 예정입니다.</li>
</ul>


# L06b: Java RMI
<h2>1. Java RMI Introduction</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/16.JPG?raw=true" alt="drawing" width="500"/>
</p>
<ul> <li>이번 강의에서는 **분산 객체 기술(distributed object technology)**이 컴퓨터 산업의 **상용 제품들에 어떤 영향을 미치고 있는지**에 대한 사례를 계속해서 살펴볼 것입니다. 먼저 다룰 주제는 **Java RMI (Remote Method Invocation)**이며, 이 기술은 지금까지 우리가 배워온 **분산 시스템의 기본 원칙들에 뿌리를 두고** 있습니다.</li> <li>Java RMI에 대해 본격적으로 이야기하기에 앞서, 분위기를 풀기 위해 **간단한 퀴즈**로 시작해보겠습니다!</li> </ul>

<h2>2. Java Language</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/17.JPG?raw=true" alt="drawing" width="500"/>
</p>

<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/18.JPG?raw=true" alt="drawing" width="500"/>
</p>

<h2>3. Java History</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/19.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>Java는 Sun Microsystems의 **James Gosling**이 발명한 언어로, 원래 이름은 **Oak**이었으며, **PDA(개인용 디지털 비서)**에서 사용하기 위해 설계되었습니다. 이후 1990년대에는 인터넷을 통한 **주문형 비디오(Video on Demand)**에 대한 관심이 높아지자, Sun은 Java가 **셋톱박스 프로그래밍**에 적합한 언어일 수 있다고 보았습니다.</li>

  <li>하지만 당시 케이블 TV 업계는 VOD 시험 서비스에 **SGI의 기술**을 선택했고, 이로 인해 Oak는 시장에서 주목받지 못하고 실패하게 되었습니다. 이 시점에서 Sun은 Oak를 거의 포기했으나, **월드 와이드 웹(WWW)**이 급속히 확산되면서 상황이 반전됩니다. Java는 웹 환경에서 **클라이언트 박스에서 실행되는 코드의 제어와 격리(containment)**를 가능하게 하는 언어로서 새로운 생명을 얻게 되었습니다.</li>

  <li>오늘날 많은 인터넷 기반 전자상거래 시스템들이 **Java 프레임워크**에 의존하고 있습니다. 이번 강의의 목적은 Java 언어 자체를 설명하는 것이 아니라, **Java의 분산 객체 모델(distributed object model)**에 대해 다루는 데 있습니다.</li>
</ul>


<h2>4. Java Distributed Object Model</h2>

<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/20.JPG?raw=true" alt="drawing" width="500"/>
</p>
<ul>
  <li>**Java의 원격 객체 모델(Java Remote Object Model)**의 장점은, 애플리케이션 프로그래머가 클라이언트-서버 시스템을 구축할 때 **RPC(Remote Procedure Call)**에서 직접 처리해야 했던 복잡한 작업—예를 들어 **마샬링(marshaling), 언마샬링(unmarshaling), 원격 객체를 네트워크에 게시(publishing)**하는 작업 등을 대부분 **Java 분산 객체 런타임이 자동으로 처리**해준다는 점입니다.  
  이 점에서 우리가 이전에 살펴본 **Spring 시스템의 서브컨트랙트(subcontract)** 메커니즘과 유사성이 보이며, Java RMI는 어떤 의미에서 그 구조적 아이디어의 연장선상에 있습니다.</li>

  <li>Java의 분산 객체 모델에서 "**원격 객체(remote object)**"란 **서로 다른 주소 공간(address space)**에서 접근 가능한 객체를 의미합니다. 그리고 "**원격 인터페이스(remote interface)**"는 원격 객체가 제공하는 **모든 메서드 선언(declaration)**을 정의한 것입니다.</li>

  <li>즉, 원격 객체가 정의되면, 원격 인터페이스를 통해 **클라이언트가 접근할 수 있는 메서드들이 무엇인지** 명시됩니다. 이 원격 인터페이스는 클라이언트와 서버 간 호출 규약의 중심이 됩니다.</li>

  <li>Java의 분산 객체 모델에서 클라이언트는 반드시 **RMI 예외(RMI exceptions)**를 처리해야 합니다. 이는 분산 환경에서의 **오류 처리 방식(failure semantics)**으로, 원격 메서드 호출 도중 발생할 수 있는 다양한 네트워크 및 실행 오류에 대응할 수 있도록 되어 있습니다.</li>

  <li>**Java의 로컬 객체(Local Object)**와 **원격 객체(Remote Object)** 사이에는 몇 가지 **유사점과 차이점**이 있습니다:
    <ul>
      <li>**유사점:** 객체 간 호출 시, **객체 참조(object reference)**를 인자로 전달할 수 있습니다. 즉, 인자로 객체를 넘길 수 있습니다.</li>
      <li>**차이점:** **로컬 객체 모델에서는 참조로 전달된 객체**를 호출된 메서드에서 수정하면, 그 변경 사항이 **호출자(클라이언트)에게 그대로 반영**됩니다.  
        반면, **분산 객체 모델에서는 객체 참조가 value-result 방식으로 전달**됩니다. 즉, **객체의 복사본**이 네트워크를 통해 전달되며, 서버 측에서 참조하는 객체는 복사된 객체입니다. 따라서 클라이언트가 그 객체를 이후에 수정하더라도 서버는 그 변경을 알 수 없습니다.</li>
    </ul>
    이처럼 **참조로 전달되는 것처럼 보이지만 실제로는 값 복사(value-result)** 방식이라는 점이 Java의 로컬 객체 모델과 분산 객체 모델 간의 **근본적인 차이점**입니다.
  </li>
</ul>


<h2>5. Bank Account Example</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/21.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>이제 **Java의 분산 객체 모델**을 실제 예제에 적용해 보겠습니다. 예제로 구성할 것은 **은행 계좌 서버(Bank Account Server)**입니다. 이 서버는 다음과 같은 기본 API를 제공합니다:  
    – **입금(deposit)**  
    – **출금(withdraw)**  
    – **잔액 조회(get balance)**  
    이러한 API들은 서버가 네트워크를 통해 제공하는 서비스가 됩니다.</li>

  <li>이제 문제는, 이러한 서비스를 Java의 분산 객체 모델을 활용하여 **가장 효과적으로 구현하는 방법**입니다. 특히, Java가 제공하는 **원격 객체(Remote Object)**와 **원격 인터페이스(Remote Interface)**라는 메커니즘을 고려할 때, **이 서비스를 네트워크 상 어디에서든 접근 가능한 분산 객체로 어떻게 구성할 수 있을지**를 고민해야 합니다.</li>

  <li>이를 위해 **두 가지 구현 가능성**을 살펴보겠습니다.</li>
</ul>

 
<h2>6. Reuse of Local Implementation</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/22.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul> <li>**첫 번째 구현 방식**은 기존의 **로컬 구현을 재사용**하는 방법입니다. 예를 들어, 개발자가 이미 구현되어 있는 로컬 클래스인 `Account`를 가지고 있다고 가정합시다. 이 개발자는 `Account` 클래스를 상속받아 (`extends`) API에서 요구하는 메서드들—**입금(deposit), 출금(withdraw), 잔액 조회(getBalance)**—을 구현하여 **`BankAccount`라는 구현 클래스**를 만듭니다.</li> <li>이제 이렇게 작성된 `BankAccount` 서비스는 네트워크 상에서 클라이언트들이 접근할 수 있도록 **외부에 노출(publish)**되어야 합니다. 이를 위해 Java 분산 객체 모델에 내장된 클래스인 **`Remote` 인터페이스**를 활용합니다. 개발자는 `BankAccount` 클래스에서 제공하는 메서드들을 **네트워크 상에서 호출 가능하게 만들기 위해**, 이 클래스의 **인터페이스를 `Remote` 인터페이스로부터 파생(extends or implements)**시킵니다. 결과적으로, 개발자는 `BankAccountInterface`라는 새로운 인터페이스를 정의하게 되며, 이 인터페이스는 이제 **네트워크 상의 클라이언트들이 접근 가능한 공개된 인터페이스**가 됩니다.</li> <li>이후 개발자가 `BankAccount` 구현 객체를 인스턴스화하면, 그 **객체의 물리적 위치(어느 주소 공간에 존재하는가)**는 클라이언트에게 **보이지 않습니다**. 클라이언트가 보게 되는 것은 오직 **`BankAccountInterface`**뿐이며, 실제 객체의 위치나 구현 내용은 클라이언트에게 노출되지 않습니다. 따라서 이 경우, 개발자는 객체를 인스턴스화한 이후, **클라이언트가 해당 객체를 찾고 접근할 수 있도록 네트워크 상에 등록하거나 게시하는 작업**을 수행해야 합니다. 이 **"heavy lifting"**, 즉 객체를 네트워크에 게시하고 위치를 노출하는 작업은 **직접 구현자가 처리해야 하는 부분**입니다.</li> <li>정리하자면, 이 첫 번째 방식은 Java 분산 객체 모델에서 제공하는 **`Remote` 인터페이스만 사용**하여, 기존 로컬 클래스를 네트워크 상에서 접근 가능한 서비스로 확장하는 방법입니다. 인터페이스를 `Remote`에서 파생시킴으로써 클라이언트는 **해당 API만 볼 수 있으며**, **구현 객체의 위치를 클라이언트가 알 수는 없기 때문에**, **추가적인 게시(publishing) 작업**은 개발자가 수동으로 수행해야 합니다.</li> </ul>

<h2>7. Reuse of Remote</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/23.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>**두 번째 구현 방식**은 Java 분산 객체 모델에 내장된 **`RemoteObject` 클래스**를 재사용하는 방법입니다.  
  앞서처럼 개발자는 **`BankAccount` 객체를 작성**하고, **입금, 출금, 잔액 조회** 등의 메서드를 구현하며, **`Remote` 인터페이스**를 사용하여 이러한 메서드를 **네트워크에서 접근 가능한 형태로 공개(publish)**합니다.  
  이 결과로 만들어지는 **`BankAccountInterface`**는 클라이언트들이 원격에서 이 객체를 호출할 수 있는 수단이 됩니다.</li>

  <li>하지만 이 방식에서 중요한 차이점은 **`BankAccount` 구현 클래스가 어떻게 파생되는가**입니다.  
  이 경우 개발자는 자신의 `BankAccountImpl` 클래스를 Java의 내장 클래스인 **`UnicastRemoteObject` (또는 예전 표현으로 `RemoteObject` 및 `RemoteServer`)**로부터 **상속(extends)**받습니다.  
  즉, 구현 클래스가 Java 분산 객체 모델의 런타임 구성요소로부터 직접 상속되어 만들어지는 것입니다.</li>

  <li>이렇게 하면 개발자가 `BankAccountImpl` 객체를 **인스턴스화만 해도**, 해당 객체는 **즉시 네트워크 클라이언트에게 노출됩니다**.  
  첫 번째 방식과는 달리 **객체를 네트워크에 게시하거나 위치 정보를 따로 전달할 필요가 없습니다.**  
  Java 런타임이 모든 “무거운 작업(heavy lifting)”—즉, 객체를 네트워크에 등록하고, 클라이언트가 접근할 수 있게 만드는 작업—을 **자동으로 처리해줍니다**.</li>

  <li>따라서 이 **두 번째 방식의 핵심 이점**은, Java 분산 객체 모델에 포함된 **런타임 클래스들을 상속**함으로써,  
  개발자가 해야 할 네트워크 등록, 객체 노출 등의 복잡한 작업을 **모두 Java 런타임이 대신 수행한다는 것**입니다.  
  결과적으로 개발자는 단순히 인터페이스를 정의하고 구현 클래스를 작성한 다음 인스턴스화하는 것만으로도 **클라이언트가 곧바로 접근 가능한 분산 객체를 구현할 수 있습니다**.</li>

  <li>이제 두 가지 방식의 차이를 요약해보면 다음과 같습니다:
    <ul>
      <li>① **Remote Interface만 사용하는 방식**: 클라이언트가 접근할 인터페이스는 공개되지만, **객체 위치를 네트워크에 수동으로 게시**해야 함</li>
      <li>② **RemoteObject/RemoteServer를 상속하는 방식**: 구현 객체를 인스턴스화하면 Java 런타임이 **자동으로 객체를 네트워크에 노출**함 → **개발자가 별도로 처리할 필요 없음**</li>
    </ul>
  </li>

  <li>이제 두 가지 선택지의 차이를 이해했으니, **퀴즈 시간입니다!**</li>
</ul>


<h2>8. Implementation Preference</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/24.JPG?raw=true" alt="drawing" width="500"/>
</p>

<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/25.JPG?raw=true" alt="drawing" width="500"/>
</p>

<h2>9. Java RMI at Work (Server)</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/26.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>이제 **Java RMI가 실제로 어떻게 작동하는지** 살펴보겠습니다.  
  **서버 측(Server side)**에서는 객체를 네트워크에 노출시키기 위해 **세 단계의 과정**이 필요합니다:
    <ol>
      <li>**객체 인스턴스화**: 먼저, 분산 서비스를 제공할 객체를 인스턴스화합니다. 예: `BankAccountImpl account = new BankAccountImpl();`</li>
      <li>**URL 생성**: 이 객체를 네트워크 상에서 식별할 수 있도록 **이름(URL)**을 정합니다. 예: `"rmi://localhost/BankService"`</li>
      <li>**객체 바인딩**: Java RMI 런타임에서 제공하는 **네이밍 서비스(naming service)**를 사용해, 생성한 URL과 인스턴스화한 객체를 **바인딩(bind)**합니다. 예:  
      `Naming.rebind("rmi://localhost/BankService", account);`</li>
    </ol>
    이 과정을 통해 해당 객체는 **Java RMI의 네임 서비스에 등록되며**, 클라이언트는 이 URL을 통해 객체의 존재를 발견하고 접근할 수 있게 됩니다.</li>
</ul>


<h2>10. Java RMI at Work (Client)</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/27.JPG?raw=true" alt="drawing" width="500"/>
</p>
<ul>
  <li>이제 **클라이언트 측(Client side)**에서 Java RMI가 어떻게 동작하는지 살펴보겠습니다.  
  네트워크 상의 **임의의 클라이언트**가 서버 객체에 접근하는 과정은 매우 간단하고 직관적입니다:
    <ol>
      <li>클라이언트는 Java RMI 시스템의 **부트스트랩 네임 서버(bootstrap naming service)**에 접속하여, 미리 게시(publish)된 **URL을 통해 서버 객체를 조회(lookup)**합니다.  
      예: `BankAccount account = (BankAccount) Naming.lookup("rmi://localhost/BankService");`</li>
      <li>이 lookup 작업이 성공하면, **클라이언트 측에 해당 객체에 대한 로컬 액세스 포인트(local proxy/stub)**가 생성됩니다.</li>
      <li>이제 클라이언트는 `account.deposit(100)`, `account.withdraw(50)`, `account.getBalance()`와 같은 **일반적인 메서드 호출 방식**으로 서버 객체를 사용할 수 있습니다.</li>
    </ol>
    클라이언트 입장에서는 이 모든 호출이 마치 **로컬 메서드 호출처럼 보이지만**, 실제로는 **네트워크를 통해 서버에 전달되는 원격 호출(remote invocation)**입니다.  
    서버가 어디에 있는지는 **클라이언트가 알 필요도, 신경 쓸 필요도 없습니다**. 서버의 위치 탐색과 통신은 **모두 Java RMI 런타임 시스템이 처리**합니다. 이것이 Java RMI의 강력한 위치 투명성(location transparency)입니다.
  </li>

  <li>물론, **네트워크 기반 시스템**이기 때문에, 원격 호출 도중 오류가 발생할 수도 있습니다. 이 경우, Java 런타임 시스템은 **`RemoteException`**을 클라이언트에게 **예외로 전달**합니다.  
  예외가 발생했다면, 클라이언트는 **호출이 실패했음을 알 수 있지만**, 정확히 **호출 도중 어느 시점에서 실패했는지**는 알 수 없습니다.  
  이처럼 네트워크 기반의 분산 시스템에서는 **예외 처리와 실패 지점의 불확실성**이 항상 고려되어야 하는 과제입니다.</li>
</ul>


<h2>11. RMI Implementation (RRL)</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/28.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>이제 Java의 **분산 객체 모델**과 이를 이용해 **서비스를 구축, 게시, 클라이언트에 노출하는 방식**을 이해했으니, 이번에는 **Java RMI(Remote Method Invocation)**가 실제로 **어떻게 구현되어 있는지**를 살펴보겠습니다.</li>

  <li>Java RMI 구현의 핵심에는 **Remote Reference Layer(RRL)**이라는 계층이 있습니다. 이 계층이 바로 많은 "마법"이 일어나는 곳입니다.  
  클라이언트 측의 **스텁(stub)**은 RRL을 통해 원격 메서드 호출을 시작하며,  
  호출 인자를 **마샬링(marshaling, 직렬화)**하여 네트워크로 전송하는 작업은 모두 **RRL이 담당**합니다.  
  마찬가지로 서버로부터 응답이 돌아오면, 결과 데이터를 **언마샬링(unmarshaling, 역직렬화)**하여 클라이언트가 이해할 수 있는 형식으로 변환하는 작업도 **RRL이 처리**합니다.</li>

  <li>서버 측에서는 **스켈레톤(skeleton)**이 존재합니다. 이 스켈레톤은 클라이언트로부터 받은 인자를 **언마샬링**하기 위해 역시 RRL을 사용합니다.  
  그 후 서버 객체로 메서드 호출을 전달하고, 처리된 결과를 다시 **마샬링**한 후 RRL을 통해 클라이언트로 전송합니다.  
  클라이언트 측에서는 이 결과가 RRL을 통해 전달되며, 스텁과 RRL이 협력하여 클라이언트에게 결과를 제공하게 됩니다.</li>

  <li>Java에서는 이 **마샬링/언마샬링**을 보통 **직렬화(serialization)/역직렬화(deserialization)**라고 부릅니다.  
  즉, 객체 인자를 전달할 때 **RRL이 객체를 직렬화**하여 전송하고, **서버 측에서는 역직렬화**하여 실제 자바 객체로 복원합니다.  
  서버가 응답으로 보내는 객체 역시 마찬가지로 직렬화/역직렬화 과정을 거쳐 클라이언트로 돌아옵니다.</li>

  <li>이제 질문은, 서버는 어디에 있는가? 단일 인스턴스인가? 복제되어 있는가?  
  이러한 세부적인 내용—**서버가 어디 있는지, 어떤 방식으로 요청을 처리하는지, 복제 서버인지, 단일 서버인지, 영속성이 있는지** 등—는 모두 **RRL 내부에 감춰져 있으며**,  
  클라이언트와 서버는 이러한 세부사항을 **전혀 알 필요가 없습니다.**  
  이 구조는 우리가 Spring 시스템에서 보았던 **서브컨트랙트(subcontract)** 메커니즘과 매우 유사합니다.</li>

  <li>결론적으로, **Remote Reference Layer**는 Java RMI의 핵심 구성요소이며,  
  다양한 **클라이언트-서버 호출 프로토콜**을 추상화하여 제공하는 계층입니다.  
  RRL 덕분에 클라이언트와 서버는 **위치, 복제, 실행 방식 등에 무관하게 객체 호출을 수행**할 수 있으며,  
  이러한 구조는 **Spring의 서브컨트랙트에서 영향을 받아 설계된 것**이기 때문에 유사성이 있는 것도 놀랄 일이 아닙니다.</li>

  <li>이제 RRL에 대해 살펴보았으니, 다음은 Java RMI의 **Transport Layer(전송 계층)**에 대해 알아보겠습니다.</li>
</ul>


<h2>12. RMI Implementation Transport</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/29.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
<li>전송 계층이 제공하는 추상화는 엔드포인트(endpoint), 트랜스포트(transport), 채널(channel), 연결(connection)입니다. 이제 이 각각에 대해 조금 더 자세히 설명하겠습니다.</li>
<li>엔드포인트는 보호 도메인(protection domain)이라고 생각하면 됩니다. 또는 자바 가상 머신(Java virtual machine)이라고도 할 수 있습니다. 이 엔드포인트는 접근 가능한 원격 객체들의 테이블을 가지고 있으며, 이를 통해 서버 코드나 클라이언트 코드가 실행될 수 있는 샌드박스 또는 보호 도메인을 제공합니다. 이것이 바로 엔드포인트입니다. 본질적으로 보호 도메인이라 할 수 있습니다.</li>
<li>연결 관리(connection management)는 흥미로운 부분인데, 이는 이러한 엔드포인트들을 서로 연결하는 모든 세부 사항과 관련됩니다. 특히, 자바 런타임 시스템의 전송 계층에서의 연결 관리는 연결을 설정하고 해제하며, 들어오는 연결을 수신하고 연결을 성립시키는 책임을 집니다.</li>
<li>그리고 두 엔드포인트 간에 연결이 성립되면, 앞서 언급한 트랜스포트라는 추상화가 등장합니다. 예를 들어 이 엔드포인트와 저 엔드포인트 간의 연결에서 연결 관리자는 UDP 트랜스포트를 사용하기로 결정할 수 있습니다. 따라서 이 두 엔드포인트 간에는 UDP 전송을 위한 채널이 설정됩니다. 이것이 전송 계층에서 포함된 UDP 트랜스포트의 기능입니다. 마찬가지로, 다른 두 엔드포인트 간에는 연결 관리자가 TCP 채널을 사용하기로 결정할 수도 있으며, 이 경우 사용되는 트랜스포트는 양쪽 모두 TCP 연결이 됩니다. 즉, 하나의 엔드포인트는 상황에 따라 다른 엔드포인트들과 통신할 때 서로 다른 트랜스포트를 사용할 수 있습니다. 어떤 방식이 가장 적절한지에 따라 어떤 종류의 연결을 설정할지 결정되며, 이것이 바로 자바 런타임의 전송 계층에서 이루어지는 연결 관리의 일환입니다. 또한 연결 관리자는 원격 메서드가 해당 엔드포인트에서 호출될 때 디스패처(dispatcher)를 찾는 역할도 합니다. 즉, 트랜스포트는 채널을 수신 대기하고 있으며, 호출이 들어오면 해당 호출을 수행할 수 있는 디스패처를 이 보호 도메인 내에서 식별하거나 찾는 책임을 집니다. 연결 관리자는 또한 연결의 생존성(liveness)을 관리하는 역할도 합니다. 어떤 엔드포인트가 사라질 경우 이를 감지하고 해당 도메인에 “이 특정 엔드포인트가 사라졌습니다. 적절한 조치를 취하세요.”라고 알려야 합니다. 이러한 생존성 모니터링도 연결 관리의 일부입니다.</li>
<li>제가 마지막으로 언급했던 추상화는 바로 연결(connection)이라는 개념입니다. 채널이 설정되면, 트랜스포트는 이 채널을 통해 연결을 사용하여 입출력(I/O)을 수행할 수 있습니다. 전송 계층의 흐름은 연결 관리에 있습니다. 들어오는 요청을 수신 대기하다가, 요청이 들어오면 채널을 설정합니다. 이 채널은 두 엔드포인트 간의 상호 합의에 의해 설정된 통신 경로입니다. 그리고 이 채널에 대해 가장 적절한 트랜스포트를 선택합니다. 채널이 설정되면, 이제 이 엔드포인트와 저 엔드포인트 사이에 연결이 형성됩니다. 이 연결을 통해 두 엔드포인트는 채널에서 I/O를 수행할 수 있게 됩니다. 이것이 RMI(Remote Method Invocation)의 전송 메커니즘이 작동하는 방식입니다.</li>
<li>앞서 살펴본 것처럼, 전송 메커니즘은 RRL 계층 아래에 위치합니다. 이를 통해 모든 객체 호출은 전송 계층을 통해 이루어질 수 있습니다. RRL 계층은 두 엔드포인트의 위치, 즉 클라이언트와 서버의 위치에 따라 어떤 전송 방식(TCP 또는 UDP 등)을 사용하는 것이 적절한지를 결정합니다. 그리고 이 결정을 전송 계층의 일부인 연결 관리자에게 전달하여, 채널을 설정하고 연결을 통해 실제 전송이 이루어지도록 합니다. 이 연결은 클라이언트와 서버 간의 구현을 위한 통신에 사용됩니다.</li>
<li>요약하자면, 자바의 분산 객체 모델은 네트워크 서비스를 구축하기 위한 강력한 수단입니다. 이 강의에서 살펴본 것은 분산 객체 모델에서 제공하는 다양한 클래스들의 일면으로, 개발자가 네트워크 객체를 생성하고 이를 클라이언트가 어디서든 사용할 수 있도록 노출하는 과정을 쉽게 만들어 줍니다. 또한, RRL 계층이 클라이언트-서버 관계를 어떻게 동적으로 설정할지 결정하는 기능도 강력합니다. 이는 우리가 스프링(Spring)에서 봤던 서브컨트랙트 메커니즘과 유사하며, 연결 관리의 유연성을 통해 클라이언트와 서버 간의 다양한 전송 방식이 네트워크 환경이나 위치에 따라 선택될 수 있도록 해 줍니다.</li>

</ul>

<h2>13. Java RMI Conclusion</h2>
<ul>
  <li>RMI 시스템 구현에는 좀 더 미묘한 문제들이 포함되어 있습니다. 예를 들어, 분산 가비지 컬렉션(distributed garbage collection), 클라이언트 측에서의 스텁(stub)의 동적 로딩, 그리고 보안 위협을 방지하기 위한 클라이언트 및 서버 측의 정교한 샌드박싱(sandboxing) 메커니즘 등이 그것입니다. 이러한 문제들에 대해서는 지정된 논문을 읽거나 인터넷을 통해 추가적으로 학습해 보시기를 권장합니다. 제가 여러분께 전하고 싶은 핵심 메시지는, 처음에는 공상처럼 들리던 많은 아이디어들이 때가 되면 실제로 사용 가능한 기술로 발전한다는 점입니다.
</li>
</ul>


# L06c: Enterprise Java Beans
<h2>1. Enterprise Java Beans Introduction</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/30.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>이제 흐름을 연결해 봅시다. 우리는 단일 CPU 운영체제 구조에서 시작하여, 병렬 컴퓨터, 그리고 분산 시스템으로 확장해 왔습니다. 그 과정에서 객체 지향 기술이 상속성과 재사용이라는 고유 개념을 통해 다양한 수준의 운영체제 구조화에 어떻게 기여하는지를 살펴보았습니다. 이제 한 걸음 더 나아가 봅니다. 대규모 분산 시스템 서비스를 위한 시스템 소프트웨어는 어떻게 구조화할 수 있을까요? 이제는 단순히 운영체제라고 부르기엔 한계가 있는 수준, 바로 대규모 분산 서비스입니다.</li>
  <li>이번 강의를 계속하면서, 우리는 객체 지향 기술이 얼마나 폭발적으로 확장되어 오늘날 여러분이 인터넷과 전자상거래에서 매일 의존하는 다양한 서비스를 제공하게 되었는지를 엿보게 될 것입니다.</li>
  <li>이번 강의에서는 엔터프라이즈 자바 빈(Enterprise Java Beans)에 대해 설명할 것입니다. 여기서 ‘자바 빈(Java Bean)’이라는 용어는 재사용 가능한 소프트웨어 컴포넌트를 의미합니다. 이는 여러 개의 자바 객체들을 하나의 번들로 묶어, 서로 다른 애플리케이션 간에 쉽게 전달되고 재사용될 수 있도록 만든 것입니다.</li>
</ul>


<h2>2. Inter Enterprise View</h2>

<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/31.JPG?raw=true" alt="drawing" width="500"/>
</p>

<ul>
  <li>우리는 모두 일상적으로 구글이나 야후를 통해 이메일을 사용하고, eBay를 통해 물건을 구매하거나 항공권 예약을 하는 등의 인터넷 서비스를 이용합니다. 이러한 서비스를 사용할 때, 우리는 우리의 워크스테이션, 노트북, 혹은 개인 모바일 기기에서 하나의 기업(enterprise)에 접근하고 있다고 생각합니다. 그리고 우리는 그 기업을 하나의 단일한 존재로 인식하곤 합니다.</li>
</ul>

     
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/32.JPG?raw=true" alt="drawing" width="500"/>
</p>          
<ul>
  <li>하지만 실제로 기업 내부를 들여다보면, 즉 기업 내부 관점(intra-enterprise view)에서 보면 그 구조는 상당히 복잡합니다. 수많은 서비스와 서버들이 상호 연결되어 있으며, 마케팅 부서, 영업 부서, 생산 부서, 재고 관리 부서, 연구 부서 등 다양한 부서들이 존재합니다. 이 모든 것들이 모여 하나의 기업을 구성하는 것입니다. 따라서 외부에서 특정 기업의 서비스를 사용하는 입장에서는 단순해 보일 수 있지만, 내부적으로는 훨씬 더 복잡한 구조를 가지고 있습니다.</li>
</ul>


<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/33.JPG?raw=true" alt="drawing" width="500"/>
</p>    

<ul>
  <li>오늘날에는 상황이 훨씬 더 복잡해졌습니다. 우리가 어떤 기업의 서비스를 이용할 때, 사실 그 기업은 다른 기업들과도 상호작용하고 있기 때문입니다. 이것이 바로 흔히 말하는 공급망 모델(supply chain model)입니다. 즉, 여러분이 요청한 서비스가 단일 기업에 의해 처리되는 것이 아니라, 그 기업이 다른 기업들과 연계하여 하나의 요청에 대한 해결책을 구성하는 방식입니다. 더욱 도전적인 상황은 기업 간의 합병이 발생할 때입니다. 예를 들어, 과거에 실제로 있었던 사례로 디지털 이큅먼트 코퍼레이션(Digital Equipment Corporation)이 콤팩(Compaq)에 인수되었고, 이후 콤팩은 다시 HP에 인수되었습니다. 이처럼 여러 기업이 합병하게 되면, 이제 하나의 기업은 세 개의 서로 다른 기업이 결합된 복합적인 형태가 됩니다. 이러한 기업의 변환에는 수많은 도전 과제가 따릅니다. 예를 들어, 서로 다른 기업 시스템 간의 상호 운용성(interoperability), 시스템 간 인터페이스 호환성(interface compatibility), 시스템의 지속적인 진화(evolution), 그리고 대규모 복합 시스템의 확장성(scalability), 신뢰성(reliability), 유지 비용 등입니다. 이 모든 것이 기업 내부뿐 아니라 기업 간에도 해결해야 할 중요한 과제들입니다.</li>
</ul>


<h2>3. Enterprise Java Beans Example</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/34.JPG?raw=true" alt="drawing" width="500"/>
</p>   
<ul>
  <li>우리는 일상적으로 사용하는 서비스들—예를 들어 항공권 예약, 지메일(Gmail), 웹서핑 등—을 대규모 서비스(giant scale services)라고 부르곤 합니다. 이는 조직 내에서 사용하는 서비스, 예를 들어 파일 서버와는 대조적입니다. 본 강의의 후반부 모듈 중에는 ‘인터넷 규모 컴퓨팅(Internet Scale Computing)’이라는 주제가 있으며, 그곳에서는 이러한 대규모 서비스를 제공하기 위한 프로그래밍 모델과 자원 관리 문제들을 다룰 예정입니다. 하지만 여기서 강조하고자 하는 핵심은, 객체 지향 기술이 이러한 서비스를 구조화하는 데 어떻게 도움을 주는지입니다.</li>

  <li>하나의 예제를 통해 이 점을 더 명확히 이해해 봅시다. 가령 여러분이 미국 애틀랜타에서 인도 첸나이까지 왕복 항공권을 구매하고자 한다고 가정해 봅시다. 몇 번의 클릭만으로 Expedia와 같은 포털에 요청을 보낼 수 있습니다. 그러면 Expedia는 여러 항공사에 접촉하여 다양한 옵션들을 수집하고, 이를 사용자에게 제시합니다. 사용자는 가격, 편의성, 보장 조건(예: 수하물이 엉뚱한 곳으로 가지 않도록) 등을 고려하여 시간을 들여 결정을 내리게 됩니다. 때로는 배우자, 가족들과 상의해야 할 수도 있습니다. 마침내 결정을 내리면, Expedia는 선택한 항공권으로 거래를 완료하고, 여러분은 티켓을 받게 됩니다. 이제 모든 것이 잘 해결된 것처럼 보일 수 있지만, 실제로는 그렇지 않습니다. 여러분이 결정을 미루고 있는 사이, 지구 반대편 어딘가에서 누군가가 거의 동일한 조건으로 같은 여행을 계획하고 있을 수도 있습니다. 동일한 날짜, 동일한 제약 조건, 동일한 목적지 등에서 여러분은 자신도 모르는 사이에 리소스를 두고 경쟁하고 있는 것입니다. 이 경우, 리소스는 바로 특정 항공편의 좌석입니다. 이러한 요청을 처리하는 Expedia와 여러 항공사들은 서로 협력하여 공간과 시간상으로 여러 클라이언트로부터 들어오는 동시 요청 간의 자원 충돌이 발생하지 않도록 조율해야 합니다.</li>

  <li>이러한 예시에서는 병렬 및 분산 시스템에서 다루었던 여러 이슈들—동기화(synchronization), 통신(communication), 작업의 원자성(atomicity), 동시성(concurrency)—이 얼마나 중요한지를 확인할 수 있습니다. 그리고 이러한 문제들은 단순해 보이는 예제 속에서도 시간과 공간을 초월하여 등장합니다. 게다가 모든 서비스는 공통적으로 필요한 기능들이 존재합니다. 예를 들어 웹 브라우저 상의 쇼핑 카트(shopping cart) 기능이 그러합니다. 이 예시는 항공권 예약이지만, 기차표 예매, 호텔 예약, 스포츠 경기 티켓 구매 등도 유사한 요구 사항을 갖고 있습니다. 그리고 그 중 많은 기능들은 반복적으로 사용될 수 있습니다. 쇼핑 카트와 같은 기능은 비록 항공권 예약과 호텔 예약처럼 서로 다른 서비스일지라도 공통적으로 필요합니다. 따라서 새로운 서비스를 구현할 때마다 매번 처음부터 새로 만들 필요는 없습니다. 바로 이 지점에서 객체 지향 기술, 즉 구성 요소의 재사용성(reuse of components)의 힘이 발휘됩니다.</li>
</ul>


<h2>4. N Tier Applications</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/35.JPG?raw=true" alt="drawing" width="500"/>
</p>   
<ul>

  <li>이러한 애플리케이션들은 흔히 N-티어(N-tier) 애플리케이션이라고 불립니다. 왜냐하면 이와 같은 애플리케이션을 구성하는 소프트웨어 스택을 살펴보면 여러 개의 계층(layer)으로 구성되어 있기 때문입니다. 먼저 프레젠테이션 계층(presentation layer)이 있습니다. 이 계층은 브라우저 화면에 화면을 렌더링하는 역할을 하며, 사용자의 요청에 따라 동적으로 페이지를 생성할 수도 있습니다. 그다음으로는 서비스가 제공하는 기능에 해당하는 애플리케이션 로직(application logic)이 있고, 항공 요금 결정, 좌석 배정 등과 같은 비즈니스 로직(business logic)이 존재합니다. 또한, 이러한 애플리케이션 로직과 비즈니스 로직이 특정 요청을 만족시키기 위해 결정을 내려야 하는 정보들을 포함하고 있는 데이터베이스 계층(database layer)도 존재합니다. 이 모든 계층은 우리가 병렬 프로그램이나 분산 프로그램 작성 시 접했던 여러 가지 이슈들을 공통적으로 고려해야 합니다. 그 중 하나가 바로 액션의 지속성(persistence)입니다.</li>

  <li>예를 들어, 제가 항공권을 선택했지만 아직 결제를 완료하지 않은 상태라고 가정해 봅시다. 저는 그 상태에서 자리를 뜨고 나중에 돌아와서 예약을 마무리할 수도 있습니다. 이런 상황에서는 지속성(persistence)이 필요합니다. 또한 트랜잭션(transaction)의 개념도 필요합니다. 사용자가 어떤 작업을 시작했지만 아직 완료하지 않았기 때문에, 시작된 예약이 중간에 잃어버려지지 않고 끝까지 완료될 수 있도록 하기 위한 트랜잭션 속성이 요구됩니다. 데이터베이스에서 가져온 데이터를 캐싱하여 데이터베이스 접근 속도를 향상시키는 데이터 캐싱(caching), 관련된 여러 서비스를 묶어서 성능을 향상시키기 위한 클러스터링(clustering), 데이터베이스 데이터에 대한 클러스터링 등도 중요한 고려 사항입니다. 그리고 오늘날 전자상거래(E-commerce)에서 가장 많이 걱정하는 부분 중 하나는 보안(security)입니다. 특히, 금융 정보나 신용카드 정보, 주민등록번호 같은 민감한 개인 정보를 주고받을 때 서버가 제공하는 서비스가 안전하며, 개인 정보가 유출되지 않는다는 보장을 우리는 원합니다. 이러한 모든 문제들은 N-티어 애플리케이션이 신뢰할 수 있는 서비스를 최종 사용자에게 제공하기 위해 반드시 고려해야 할 필수 요소들입니다.</li>

<li>그렇다면 이러한 N-티어 애플리케이션을 어떻게 구조화할 수 있을까요? 우리가 줄이고자 하는 것은 네트워크 통신의 양입니다. 네트워크 통신이 많아지면 지연(latency)이 발생하게 되며, 이는 성능 저하로 이어집니다. 또한 사용자 측면에서는 보안 위험을 줄여야 합니다. 이는 곧 비즈니스 로직이 외부에 노출되거나 침해되지 않아야 함을 의미합니다. 동시에 개별 요청을 처리할 때 더 높은 수준의 동시성(concurrency)을 확보하는 것도 중요합니다. 예를 들어, 하나의 개별 요청이 들어왔을 때, 그 요청을 처리하는 과정에서 병렬성을 활용할 수 있는 기회가 있을 수 있습니다.</li> <li>이러한 애플리케이션은 흔히 ‘당연히 병렬적인(embarrassingly parallel)’ 애플리케이션이라고도 불립니다. 왜냐하면 비록 하나의 요청처럼 보일지라도, 실제로는 병렬 처리가 가능한 여러 작업들로 구성되어 있기 때문입니다. 예를 들어, 사용자가 특정 날짜에 좌석이 있는지를 알고 싶다고 요청했다고 가정해 봅시다. 사용자는 어떤 항공사를 이용하든 상관이 없다고 했기 때문에, 이는 Expedia 서버 입장에서 여러 항공사에 병렬적으로 동시에 쿼리를 보내 좌석 정보를 받아올 수 있는 기회가 됩니다. 이처럼 하나의 요청 안에서 병렬성을 활용할 수 있는 기회가 존재합니다.</li> <li>또한, 여러 개의 동시 요청이 들어올 때 이들 사이에서도 동시성을 활용할 수 있습니다. 서버에서 동시에 도착하는 요청들을 처리할 때 공통적인 연산이 필요한 경우, 해당 연산을 클러스터링하여 효율적으로 처리할 수도 있습니다. 이러한 구조화에서는 구성 요소(component)의 재사용을 적극적으로 활용해야 합니다. 여기서 구성 요소란, 애플리케이션 로직의 일부분으로, 다양한 애플리케이션을 구축할 때 반복적으로 재사용할 수 있으며, 동시에 여러 클라이언트로부터 들어오는 요청을 처리하는 실행 과정에서도 활용할 수 있는 코드 블록을 의미합니다.</li>

</ul>


<h2>5. Structuring N Tier Applications</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/36.JPG?raw=true" alt="drawing" width="500"/>
</p>   

<ul>
<li>다층(N-tier) 애플리케이션을 구성하는 방법을 설명하기 위해 하나의 프레임워크를 예시로 사용할 것입니다. 이는 단지 예시일 뿐이며, Java Enterprise Edition(JEE) 프레임워크처럼 유사한 기능을 제공하는 다른 프레임워크들도 존재합니다. JEE 프레임워크에서는 애플리케이션 서비스를 구성하기 위해 네 가지 컨테이너가 사용됩니다. 컨테이너는 일반적으로 Java 가상 머신에서 구현되는 보호 도메인(protection domain)으로 생각할 수 있습니다.</li>  
<li>JEE 방식의 N-tier 애플리케이션 구성에는 네 가지 컨테이너가 있습니다. 클라이언트 컨테이너와 클라이언트를 위한 애플릿 컨테이너가 있으며, 이 애플릿 컨테이너는 일반적으로 웹 서버에 위치하게 됩니다. 이 컨테이너는 최종 클라이언트의 브라우저와 상호작용합니다. 앞서 언급한 프레젠테이션 로직은 웹 컨테이너라는 컨테이너에 의해 제공되며, 이 컨테이너는 웹 서버가 클라이언트 브라우저로 다시 전송해야 할 페이지를 동적으로 생성하는 역할을 담당합니다. 비즈니스 로직을 관리하는 컨테이너는 EJB 컨테이너라고 하며, 이는 클라이언트로부터 들어온 요청을 처리하는 데 필요한 작업을 수행합니다. 비즈니스 로직은 요청 처리를 위해 필요한 데이터를 가져오기 위해 데이터베이스 서버와 통신할 수 있습니다. 따라서 이 네 가지 컨테이너 — 클라이언트 컨테이너, 애플릿 컨테이너, 웹 컨테이너, EJB 컨테이너 — 는 특정 서비스를 제공하는 전체 애플리케이션을 구성하는 객체들을 패키징하기 위해 사용됩니다. 예를 들어 항공권 예약 서비스나 호텔 예약 서비스 등이 해당됩니다.</li>  
<li>핵심 목표는 가능한 한 많은 컴포넌트를 재사용하는 것입니다. 이 목적을 위해 자바(Java)의 커피 비유를 계속해서 사용하며, ‘빈(bean)’이라는 단어는 특정 기능을 제공하는 자바 객체들의 묶음을 의미하는 단위로 사용됩니다. 예를 들어, 쇼핑 카트 기능을 제공하는 빈이 있을 수 있습니다. 이 빈은 N-tier 애플리케이션을 구성할 때 재사용되는 단위가 됩니다. 앞서 언급한 컨테이너들은 이러한 빈을 호스팅합니다. 즉, 컨테이너는 여러 자바 빈을 패키징하고 해당 컨테이너 내에서 사용할 수 있도록 합니다. 이것이 JEE 프레임워크에서의 개념입니다.</li>  
<li>빈에는 네 가지 유형이 있으며, 그 중 하나는 엔티티 빈(entity bean)입니다. 예를 들어, 하나의 엔티티 빈은 데이터베이스의 한 행(row)에 해당할 수 있습니다. 예를 들어 직원 정보를 저장하는 데이터베이스를 생각해보면, 하나의 행은 성(last name)이 ‘a’로 시작하는 모든 직원을 나타낼 수 있습니다. 일반적으로 엔티티 빈은 기본 키(primary key)를 가진 지속 가능한(persistent) 객체입니다. 엔티티 빈의 지속성(persistence)은 빈 자체에 내장될 수도 있으며, 이를 빈 관리 지속성(bean-managed persistence)이라고 합니다. 또는 엔티티 빈이 인스턴스화되는 컨테이너에 내장될 수도 있으며, 이 경우 컨테이너 관리 지속성(container-managed persistence)이라고 합니다. 어느 경우든 지속성이 필요한 객체를 다루는 것이므로, 해당 객체의 지속성은 엔티티 자체 또는 그것을 호스팅하는 컨테이너 중 한 곳에서 반드시 처리되어야 합니다.</li>
<li>두 번째 유형의 빈은 세션 빈(session bean)이라고 불립니다. 세션 빈은 일반적으로 특정 클라이언트와 연결되어 있으며, 클라이언트가 서비스와 상호작용하는 시간적 범위, 즉 세션(session)에 연관되어 있습니다. 세션 빈은 이러한 세션 정보를 보유할 수 있습니다. 세션 빈은 상태 저장(stateful)일 수도 있고, 예를 들어 Dell 포털에 접속해 컴퓨터를 주문한다고 가정할 때, 이 세션은 내가 선택한 옵션들을 기억해야 하므로 상태 저장 세션이어야 합니다. 사용자는 이러한 선택 정보를 유지한 채 잠시 자리를 비우고, 다음 날 다시 돌아와 구매를 이어갈 수도 있습니다. 이런 경우 세션은 상태 저장이어야 합니다. 반면에 상태 비저장(stateless) 세션도 존재할 수 있습니다. 예를 들어, 브라우저를 통해 Gmail을 사용하는 이메일 세션을 시작한다면, 이 세션은 상태 비저장일 수 있습니다. 사용자가 자리를 비운 후 세션에서 수행한 모든 작업은 폐기되고, Gmail 서버에 다시 연결할 때는 완전히 새로운 세션이 시작되기 때문입니다. 이러한 의미에서 세션 빈은 상태 저장 세션 빈일 수도 있고, 상태 비저장 세션 빈일 수도 있습니다.</li> <li>세 번째 유형의 빈은 메시지 기반 빈(message-driven bean)입니다. 이 유형의 빈은 비동기적(asynchronous) 동작에 유용합니다. 예를 들어, 주식 시세를 알고 싶어하는 사용자가 브라우저에서 주식 시세 표시기를 사용하고, 특정 회사의 주식 변동 정보를 계속 받아보고자 할 경우, 이는 메시지 기반 빈을 통해 이루어질 수 있습니다. 메시지 기반 빈은 이러한 비동기 동작을 수행합니다. 주식 시세 표시기(stock ticker), 뉴스 피드(news feed), 요즘 일반적으로 사용하는 RSS 피드 등이 메시지 기반 빈의 예시입니다. 각각의 빈은 특정 기능을 나타내며, 이러한 빈들을 더욱 세분화할수록 개별 요청이나 동시 요청(concurrent request)에 대해 더욱 높은 수준의 동시성(concurrency)을 확보할 수 있게 됩니다. 즉, 애플리케이션 서버로 들어오는 요청들이 병렬로 처리되기 쉬워집니다. 하지만 빈을 더 세분화해서 구현한다는 것은 그만큼 비즈니스 로직이 더 복잡해진다는 것을 의미합니다. 따라서 이러한 다층 애플리케이션을 구조화할 때에는 항상 이런 트레이드오프(trade-off)가 존재합니다. 더 세밀한 동시성을 지원하기 위해 복잡한 비즈니스 로직을 감수할 수도 있고, 반대로 단순한 비즈니스 로직을 유지하기 위해 빈을 덜 세분화할 수도 있습니다. 이러한 다양한 설계 대안을 논의하는 것이 앞으로 다룰 핵심 주제가 될 것입니다.</li>
</ul>

<h2>6. Design Alternative (Coarsegrain Session Beans)</h2>

<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/37.JPG?raw=true" alt="drawing" width="500"/>
</p>   

<ul>
<li>우리가 처음으로 살펴볼 설계 대안은 coarse-grain 세션 빈을 사용하는 것입니다. 제가 보여드리는 이 구조에서는 웹 컨테이너만을 살펴보고 있으며, 클라이언트와 인터페이스하는 애플릿 컨테이너는 웹 브라우저에 있으므로 여기서는 고려하지 않습니다. 우리는 다양한 설계 대안에서 웹 컨테이너와 EJB 컨테이너를 어떻게 구성할지에 대해서만 이야기할 것입니다. 웹 컨테이너는 프레젠테이션 로직을 포함하고 있으며, 제가 보여드리는 구조에서 서블릿은 특정 클라이언트와의 개별 세션에 대응됩니다. 이 상자는 특정 클라이언트를 나타내고, 저 상자는 두 번째 클라이언트를 나타냅니다. 첫 번째 클라이언트에 해당하는 서블릿 1에는 그에 상응하는 프레젠테이션 로직이 있고, 마찬가지로 두 번째 클라이언트에 해당하는 서블릿 2에도 프레젠테이션 로직이 있습니다. 각 서블릿에는 coarse-grain 세션 빈이 연결되어 있으며, 이 세션 빈은 서블릿 1을 통해 서비스되는 클라이언트에 해당합니다. 마찬가지로 서블릿 2는 이 세션 빈을 통해 서비스됩니다. 그리고 이름에서 알 수 있듯이, 이 세션 빈은 해당 세션 동안 서비스를 받는 특정 클라이언트의 요구사항을 처리하는 역할을 합니다.</li>

<li>따라서 세션 빈은 비즈니스 로직이 작동하기 위해 데이터베이스에 접근해야 할 필요가 있을 때 그 데이터 접근을 담당하게 됩니다. 예를 들어, 항공 예약 시스템을 운영하고 있고 이 클라이언트가 특정 예약을 요청하고 있다면, 이 세션 빈이 데이터베이스 서버에 접속하여 비즈니스 로직이 해당 클라이언트의 요청에 맞는 필터링 및 선택 작업을 수행하는 데 필요한 날짜 및 항공 예약 정보를 가져오는 역할을 하게 됩니다. 동시에 여러 클라이언트가 이 서비스를 요청하면, 그에 따라 EJB 컨테이너에는 여러 세션이 포함될 수 있습니다. 따라서 EJB 컨테이너는 서버에서 동시에 실행되는 모든 세션에 대해 서비스를 제공해야 합니다. 각 세션에 필요한 모든 데이터 접근은 해당 세션 빈이 처리하므로, 이 모델을 지원하기 위해 EJB 컨테이너로부터 필요한 서비스는 최소화됩니다. 실제로는 서로 다른 세션 빈이 외부 리소스에 접근하면서 충돌이 발생할 수 있는 경우에만 조정 서비스를 제공하면 됩니다. 예를 들어, 여러 세션이 동일한 데이터베이스의 같은 부분에 쓰기 작업을 하려고 할 때가 그런 경우입니다.</li>
<li>이 경우에는 EJB 컨테이너 서비스로부터 약간의 조정 지원이 필요할 수 있습니다. 이 구조의 또 다른 중요한 특징은 비즈니스 로직이 기업 내부 네트워크에 국한된다는 점입니다. 웹 컨테이너에 포함되지 않고 EJB 컨테이너에 포함되어 있기 때문에 외부 세계에 노출되지 않습니다. 이는 긍정적인 요소입니다. 따라서 이 구조의 장점은 컨테이너 서비스가 최소한으로 필요하다는 점과, 비즈니스 로직이 외부에 노출되지 않는다는 점입니다.</li>

<li>하지만 이 구조의 단점은, 이 애플리케이션 구조가 우리가 자주 언급했던 모놀리식 커널(monolithic kernel)과 매우 유사하다는 점입니다. 데이터베이스의 서로 다른 부분에 접근하는 데 있어서 동시성이 매우 제한적입니다. 예를 들어, 이처럼 대규모 서비스를 제공하는 시스템에서는 작업이 놀라울 정도로 병렬적으로 이루어질 수 있습니다. 많은 데이터를 동시에 가져올 수 있는 기회가 존재합니다. 예를 들어, 회사 전체 직원의 인구 통계를 수집하는 쿼리가 있다고 하면, 이 경우 데이터베이스로부터 대량의 데이터를 동시에 가져올 수 있는 기회가 있습니다. 그러나 불행하게도 이 구조는 그러한 병렬성을 활용할 수 없게 되어 있습니다. 다시 말해, 이 coarse-grain 세션 구조는 동일한 요청이든, 동일한 데이터베이스의 동일한 부분에 접근하는 동시 요청이든 간에, 병렬적으로 데이터를 접근하고 가져오는 기회를 놓치게 되는 구조입니다.</li>

</ul>

<h2>7. Design Alternative (Data Access Object)</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/38.JPG?raw=true" alt="drawing" width="500"/>
</p> 
<ul>
<li>제가 말씀드릴 두 번째 설계 대안은 앞서 언급했던 문제를 정확히 완화하는 구조입니다. 즉, 데이터베이스 접근에서 병렬성을 확보하는 것이 핵심입니다. 왜냐하면 요청을 처리하는 전체 과정에서 데이터베이스 접근이 아마도 가장 느린 연결 고리이기 때문입니다. 디스크를 통한 I/O 작업과 네트워크를 통해 데이터를 컨테이너로 가져오는 데 시간이 많이 걸리기 때문입니다. 이러한 이유로 이 구조에서는 서블릿과 프레젠테이션 로직이 존재하던 컨테이너 안에 비즈니스 로직도 추가하여, 소프트웨어 구조를 3계층으로 구성합니다. 서블릿 프레젠테이션 로직, 비즈니스 로직, 그리고 모든 데이터 접근은 entity bean을 통해 수행됩니다. 앞서 언급했듯이, entity bean은 지속성 특성을 가지며, 이 예제에서는 entity bean이 데이터베이스의 한 행(row)을 나타낸다고 볼 수 있습니다. 데이터 접근 객체는 여러 개의 entity bean으로 구현되며, 설계자는 하나의 entity bean이 데이터베이스의 한 행을 담당할지, 아니면 여러 행을 담당할지를 선택할 수 있습니다. 어쨌든, 우리가 한 일은 데이터베이스 접근에 있어서 활용 가능한 병렬성을 entity bean을 통해 구조화한 것입니다. 이렇게 하면 데이터 접근 단위 수준에서 병렬 접근이 가능해집니다. 이제 EJB 컨테이너는 이러한 entity bean들을 포함하게 됩니다.</li>

<li>따라서 특정 클라이언트를 서비스하는 서블릿이 데이터베이스의 일부에 접근할 필요가 있을 경우, 원하는 만큼 entity bean에 병렬 요청을 보낼 수 있습니다. 이 entity bean들은 모두 단일 클라이언트를 대신해서 병렬로 작동하며 필요한 데이터를 가져와 비즈니스 로직에 제공하게 됩니다. 이 병렬 구조를 통해 데이터 접근 시간을 줄이고, I/O 성능 측면에서 존재할 수 있는 병렬성을 최대한 활용할 수 있게 됩니다. 그리고 병렬 요청이 발생하더라도, 이러한 병렬 요청들이 동일한 데이터베이스의 동일한 부분에 접근할 수 있습니다. 앞서 예로 든 것처럼 두 명의 서로 다른 사용자가 동일한 날짜와 동일한 조건으로 항공 예약을 시도하는 경우, entity bean은 여러 클라이언트로부터 들어오는 요청을 클러스터링하여, 동시에 발생하는 여러 클라이언트의 데이터베이스 접근을 통합하고 분산시켜 효율적으로 처리할 수 있습니다.</li>

<li>앞서 언급했듯이, entity bean은 일반적으로 영속적인 상태(persistent state)를 다루기 때문에, 이러한 entity bean에 일정 수준에서 영속성(persistence)을 제공해야 합니다. 즉, entity bean을 사용하는 데이터 접근 객체(Data Access Object)에도 일정한 수준에서 영속성이 제공되어야 합니다. 이 영속성은 개별 entity bean 수준에서 제공될 수도 있는데, 이를 bean 관리 영속성(Bean-Managed Persistence)이라고 합니다. 이 경우, bean이 직접 데이터 접근 객체의 영속성을 관리합니다. 반대로 컨테이너가 이 기능을 제공할 수도 있으며, 이 경우에는 컨테이너 관리 영속성(Container-Managed Persistence)이라고 합니다. 따라서 이 구조에서 우리가 선택할 수 있는 두 가지 설계 옵션이 존재합니다. 설계 대안 2에서 구조는 동일합니다. 즉, entity bean을 사용하여 데이터 접근 객체를 구현하고, 애플리케이션 서비스 구성 시 원하는 동시성 수준에 따라 데이터 접근 객체의 세분화 정도를 결정합니다. 그러나 이 선택 내에서 또다시 두 가지 옵션이 존재하는데, 데이터 접근 객체에 대한 영속성을 entity bean 내부에서 제공할 것인지, 아니면 컨테이너 서비스를 통해 제공할 것인지를 선택해야 합니다.</li>

<li>이러한 설계는 사용 가능한 다양한 기능을 재사용할 수 있는 기회를 제공하기도 합니다. 예를 들어, 동일한 컨테이너 관리 영속성 기능은 서로 다른 유형의 애플리케이션에서 재사용될 수 있습니다. 하나는 항공 예약 애플리케이션일 수도 있고, 다른 하나는 호텔 예약 포털일 수도 있습니다. 이러한 다양한 애플리케이션들이 동일한 컨테이너 관리 영속성 기능을 활용할 수 있는 것입니다.</li>

<li>이 구조의 장점은, 첫째로 동시성을 실질적으로 활용할 수 있다는 점입니다. 동일 클라이언트를 위한 데이터 접근을 병렬로 수행하거나, 서로 다른 클라이언트 간에도 유사한 서비스 요청으로 인한 중복된 데이터 접근을 통합하여 병렬성을 활용할 수 있습니다. 이런 방식으로 데이터 접근 병목을 줄일 수 있고, 동시에 서비스 효율을 높일 수 있습니다. 이것이 긍정적인 요소입니다.</li>

<li>하지만 이 접근 방식에는 단점도 하나 있습니다. 그것은 비즈니스 로직이 EJB 컨테이너에서 웹 컨테이너로 이동함에 따라, 비즈니스 로직이 외부 네트워크에 노출된다는 점입니다. 즉, 이 구조에서는 기업 내부 네트워크에 국한되지 않고 외부에서 비즈니스 로직에 접근이 가능해진다는 것입니다. 앞서 설명했던 이전 구조에서는 데이터 접근 로직이 세션 빈에 포함되어 있었지만, 이제는 모든 데이터 접근 로직이 entity bean으로 이동되었습니다. 이러한 구조 덕분에 동일한 데이터 접근 로직을 여러 entity bean이 보유하게 되어, 데이터베이스의 서로 다른 부분을 동시에 접근할 수 있고, 병렬성을 활용하여 비즈니스 로직이 필요한 데이터를 빠르게 가져올 수 있게 되는 것입니다.</li>

</ul>


<h2>8. Design Alternative (Session Bean With Entity Bean)</h2>
<p align="center">
   <img src="https://github.com/audrey617/CS6210-Advanced-Operating-Systems-Notes/blob/main/img/l6/39.JPG?raw=true" alt="drawing" width="500"/>
</p> 

<ul>
<li>두 번째 설계 대안은 동시성을 제공했지만 그 대가로 비즈니스 로직이 외부에 노출되는 문제가 있었습니다. 이제 설명할 세 번째 설계 대안은 이를 보완하기 위해 세션 빈과 엔터티 빈을 함께 사용합니다. 핵심 아이디어는 각 클라이언트 세션마다 세션 퍼사드(Session Facade)라는 디자인 패턴을 적용해 특정 클라이언트에 연결된 세션을 생성·연계한다는 점입니다. 예를 들어, 여기서 한 세션 퍼사드는 서블릿 1에 대응하며, 이는 해당 서블릿이 서비스하는 클라이언트 1에 매핑됩니다. 마찬가지로 다른 세션 퍼사드는 클라이언트 2를 담당합니다. 첫 번째 설계와 마찬가지로 웹 컨테이너에는 해당 서블릿과 그 프레젠테이션 로직만 존재합니다. 비즈니스 로직은 다시 EJB 컨테이너로 이동해 세션 퍼사드와 함께 위치합니다. 또한 두 번째 설계 대안에서 언급했던 엔터티 빈 개념을 활용해 데이터 액세스 객체(DAO)를 계속 구현합니다. 따라서 세션 퍼사드는 자신과 연관된 비즈니스 로직이 필요로 하는 모든 데이터 액세스를 처리하며, 다른 세션 퍼사드도 동일하게 동작합니다. 세션 퍼사드는 이 세션에 해당하는 비즈니스 로직의 데이터 액세스 요청을 여러 엔터티 빈에 병렬로 위임합니다. 데이터베이스의 서로 다른 부분을 담당하는 여러 엔터티 빈에 동시에 요청을 보낼 수 있으므로 다시 한번 병렬성을 활용할 기회가 있습니다. 두 번째 설계 대안과 마찬가지로 데이터베이스를 우리가 적절하다고 판단한 임의의 세분화 수준으로 구조화할 수 있습니다. 어떤 엔터티 빈은 특정 행 하나 또는 행들의 클러스터를 담당하도록 할 수 있습니다. 이렇게 하면 원하는 수준의 세분화로 병렬 액세스를 구현해 비즈니스 로직 처리를 병렬화할 수 있으며, 동시에 비즈니스 로직을 EJB 컨테이너 내부로 이동시켰기 때문에 비즈니스 로직이 사내 네트워크 밖으로 노출되지 않습니다.</li>

<li>세션 빈과 엔터티 빈을 어떻게 구성할지에 대해 몇 가지 선택지가 있습니다. 먼저 웹 컨테이너는 Java 분산 객체 프레임워크의 원격 인터페이스(RMI)를 통해 비즈니스 로직과 통신합니다. 세션 퍼사드 역시 엔터티 빈과 통신할 때 RMI를 사용할 수 있습니다. 이 경우 세션 퍼사드와 엔터티 빈 사이의 상호작용은 서블릿과 세션 퍼사드 사이의 상호작용과 매우 유사하며, 모두 RMI를 사용합니다. 또는 세션 퍼사드와 엔터티 빈 사이의 인터페이스를 로컬 인터페이스로 구성할 수도 있습니다. 두 옵션 중 하나를 선택하는 이유는 다음과 같습니다. RMI를 사용하면 엔터티 빈을 네트워크상의 원하는 위치에 배치할 수 있는 유연성을 확보할 수 있습니다. 반면 로컬 옵션을 선택하면 엔터티 빈을 비즈니스 로직과 세션 퍼사드가 있는 동일한 EJB 컨테이너에 함께 배치하게 됩니다. 로컬로 배치하면 네트워크 통신 비용 없이 엔터티 빈에서 데이터를 가져올 수 있다는 장점이 있습니다. 물론 엔터티 빈 자체는 데이터베이스 서버에서 데이터를 읽어와야 하지만, 이를 비즈니스 로직에 전달할 때 추가로 네트워크를 거칠 필요가 없습니다. 따라서 이 설계 대안 내에서도 해당 부분을 원격 인터페이스로 구현할지, 로컬 인터페이스로 구현할지를 선택해야 합니다.</li>

<li>그리고 이 구조의 장문(prose)은 일종의 두 마리 토끼를 잡는 것입니다. 첫 번째 설계 대안의 미덕이었던 비즈니스 로직의 비노출을 유지하면서, 엔터티 빈으로 구현된 데이터 액세스 객체를 통해 동시성도 확보합니다. 따라서 비즈니스 로직이 사내 네트워크 내부에 위치한다는 장점과 동시성이 모두 이 설계 대안에서 제공됩니다.</li> <li>단점이 있을까요? 데이터 액세스를 위해 추가적인 네트워크 접근이 발생한다는 점입니다. 이를 완화하려면 엔터티 빈과 세션 퍼사드를 동일한 EJB 컨테이너에 공배치(co-locating)하면 됩니다. 이것은 선택 가능한 옵션입니다.</li> <li>지금까지 논의한 세 가지 설계 대안은 다음과 같습니다. 첫 번째는 거친 단위의 세션 빈 대안이고, 두 번째는 더 세분화된 데이터 액세스 객체 대안이며, 세 번째는 이 두 가지를 결합한 형태로, 세션 빈을 퍼사드로 두고 엔터티 빈으로 구현된 데이터 액세스 객체에 접근해 동시성을 확보하는 방식입니다. 이러한 다양한 설계 대안을 이야기할 때, 우리는 오로지 애플리케이션을 어떻게 분할할 것인지—클라이언트에 대한 프레젠테이션, 요청을 처리하기 위한 기업의 결정 로직인 비즈니스 로직, 그리고 필요한 데이터를 얻기 위한 데이터베이스 액세스—에 대해서만 다루고 있습니다. 물론 보안, 영속성(persistence) 등 애플리케이션 로직 외에도 고려해야 할 요소가 많습니다. 객체 지향 기술의 힘은 이러한 복잡한 서비스를 구성할 때 재사용 가능한 컴포넌트를 활용해 애플리케이션을 구조화할 수 있다는 점에 있습니다.</li>
</ul>


<h2>9. Enterprise Java Beans Conclusion</h2>
<li>이 강의에서는 복잡한 애플리케이션 서버를 구조화하는 데 있어 객체 기술의 강력함을 보여주었습니다. EJB는 개발자가 보안, 로깅, 영속성(persistence) 등과 같은 횡단 관심사(crosscutting concerns)에 대해 걱정하지 않고 비즈니스 로직을 작성할 수 있도록 해주었습니다.</li> <li>과제로는, 강의에서 논의한 설계 선택 사항들을 이해하고, 동시성(concurrency), 자원 풀링(pooling of resources), 객체 클래스 수, 코드 라인 수(lines of code) 등에 대해 해당 설계 선택이 성능에 미치는 영향을 정성적으로 분석해 보시기 바랍니다.</li> <li>또한 이 주제의 읽기 자료로 지정한 논문을 읽고, 논문에서 제시된 논증을 본인의 정성적 분석과 연결해 보십시오. 다만 한 가지 주의할 점은, 이 논문이 작성된 시점 이후로 EJB는 상당히 발전해 왔지만 논문에서 논의된 원칙들은 오늘날에도 복잡한 N-티어 애플리케이션을 구조화하는 방식에 여전히 적용된다는 것입니다.</li>
</ul>

<!-- <h2></h2>

<p align="center">
   <img src="" alt="drawing" width="500"/>
</p>

<ul>
  <li></li> 
  <li></li> 
  <li></li> 

</ul> -->
